<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Express cors 中间件和自定义中间件函数设置 Header 的区别</title>
    <link href="/blog/2024/03/25/Express-cors-%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%87%BD%E6%95%B0%E8%AE%BE%E7%BD%AE-Header-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/blog/2024/03/25/Express-cors-%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%87%BD%E6%95%B0%E8%AE%BE%E7%BD%AE-Header-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>今天又踩了个大坑，问题是这样的。<br>我正在使用 <code>GraphQL</code> 的 SANDBOX 环境测试接口，需要 <code>Express</code> 配置跨域。origin 的值是 <code>https://studio.apollographql.com</code> , 本来是一件很简单的事情，但是我又折腾了一个下午。</p><p>一开始沙盒环境请求 <code>http://localhost:8080/graphql</code> 报错，</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at [http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">8080</span><span class="hljs-regexp">/graphql](http:/</span><span class="hljs-regexp">/localhost:8080/g</span>raphql <span class="hljs-string">&quot;http://localhost:8080/graphql&quot;</span>). (Reason: CORS request did not succeed). Status code: (null).<br></code></pre></td></tr></table></figure><p>我心想这简单，配置一下<code> Access-Control-Allow-Origin</code> 设置为 <code>*</code> 即可。但是呢，因为后续需要模拟登录状态，保存 Cookie, 需要设置 <code>Access-Control-Allow-Credentials</code> 为 <code>true</code>, 那么 <code>Access-Control-Allow-Origin</code> 就不能为 <code>*</code> 通配符了。所以 <code>Access-Control-Allow-Origin</code> 需要设置为具体的值 <code>https://studio.apollographql.com</code> ，形成一个类似于白名单的效果。<br><br>最终的设置:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br>    res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&quot;Access-Control-Allow-Credentials&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>);<br>    res.<span class="hljs-title function_">setHeader</span>(<br>        <span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span>,<br>        <span class="hljs-string">&quot;https://studio.apollographql.com&quot;</span><br>    );<br>    res.<span class="hljs-title function_">setHeader</span>(<br>        <span class="hljs-string">&quot;Access-Control-Allow-Methods&quot;</span>,<br>        <span class="hljs-string">&quot;GET,HEAD,PUT,PATCH,POST,DELETE&quot;</span><br>    );<br>    <span class="hljs-title function_">next</span>();<br>&#125;);<br></code></pre></td></tr></table></figure><p>但是 <code>GraphQL</code> 的沙盒环境还是一直报错，<code>405 Method Not Allowed</code> , 即使设置了 <code>Access-Control-Allow-Methods: GET,HEAD,PUT,PATCH,POST,DELETE</code> 也不行，预检请求响应字段里面还有一个 <code>ALLOW: &quot;GET, POST&quot;</code>, 看了一下 MDN 文档，发现是 405 的响应必须要一个 ALLOW 字段，显示当前 server 支持的请求方法列表。</p><p><strong>我的疑惑来了，我明明配置了跨域的请求方法，为什么还会报错</strong>？</p><p>想了好久。<br><br>用 <code>cors</code> 中间件设置跨域的参数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">use</span>(<br>    <span class="hljs-title function_">cors</span>(&#123;<br>        <span class="hljs-attr">credentials</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">origin</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">CLIENT_URL</span>,<br>    &#125;)<br>);<br></code></pre></td></tr></table></figure><p>居然就不报错了，奇怪啊。去翻看了一下 <code>cors</code> 的源代码，不长，就两百多行。</p><p>我发现除了一些基础的配置之外， <code>cors</code> 做了一个判断，当请求的方法是 <code>OPTIONS</code> 的时候，直接 <code>res.end()</code> 结束了响应，而其他情况，则调用 <code>next()</code>, 继续往下运行。</p><p>到这个时候，我明白了。<br><br>OPTIONS 预检请求，是询问 server 是否当前 origin 可以访问，一般来讲，预检请求成功返回，就是代表 origin 可以做请求了（由浏览器控制）。这个时候，server 再定义一些字段来精细化控制后续的请求。<br><br>我遇到的情况报错是因为, 针对预检请求，没有做特殊处理，导致后续的 <code>Apollo Server</code> 对这个 <code>OPTIONS</code> 请求报错了，导致预检请求失败。前面所做的配置，也就无效了。<br><br>所以说, 自定义预检请求的中间件函数应该这样写:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br>    res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&quot;Access-Control-Allow-Credentials&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>);<br>    res.<span class="hljs-title function_">setHeader</span>(<br>        <span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span>,<br>        <span class="hljs-string">&quot;https://studio.apollographql.com&quot;</span><br>    );<br>    res.<span class="hljs-title function_">setHeader</span>(<br>        <span class="hljs-string">&quot;Access-Control-Allow-Methods&quot;</span>,<br>        <span class="hljs-string">&quot;GET,HEAD,PUT,PATCH,POST,DELETE&quot;</span><br>    );<br>    <span class="hljs-keyword">if</span> (req.<span class="hljs-property">method</span> === <span class="hljs-string">&quot;OPTIONS&quot;</span>) &#123;<br>        res.<span class="hljs-title function_">send</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">next</span>();<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>针对预检请求，设置完参数后，直接返回，不要让后续的中间件再进行处理了。<br><br>弄清楚问题后，我直接注释了我写的配置，直接使用用 <code>cors</code> 中间件配置, 一了百了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>后端开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ts-node-dev + redis 运行 demo 踩坑记录</title>
    <link href="/blog/2024/03/19/ts-node-dev-redis-%E8%BF%90%E8%A1%8C-demo-%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <url>/blog/2024/03/19/ts-node-dev-redis-%E8%BF%90%E8%A1%8C-demo-%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>运行一个后端的小 demo, 技术栈是 ts-node-dev + redis + express。耽误了一整天, 就做了这点事, 不写个文章记录一下，真对不起我花的这么多时间。</p><p>第一个坑点:</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fortran">error TS2688: Cannot find <span class="hljs-keyword">type</span> definition <span class="hljs-keyword">file</span> for <span class="hljs-string">&#x27;ioredis&#x27;</span>.<br>  The <span class="hljs-keyword">file</span> is <span class="hljs-keyword">in</span> the <span class="hljs-function"><span class="hljs-keyword">program</span></span> because:<br>    <span class="hljs-built_in">Entry</span> point for <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">type</span> library <span class="hljs-string">&#x27;ioredis&#x27;</span><br></code></pre></td></tr></table></figure><p>这是 <code>tsconfig.json</code> 文件报的错。疑惑的是，我明明安装了 <code>@types/ioredis</code> 依赖包，似乎没有起作用。去搜索了一下原因，发现仓库赫然写着:</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">Author message:<br><br>This <span class="hljs-keyword">is</span> a stub types definition. ioredis provides its own <span class="hljs-keyword">type</span> <span class="hljs-type">definitions, </span>so you <span class="hljs-keyword">do</span> <span class="hljs-keyword">not</span> need this installed.<br></code></pre></td></tr></table></figure><p>也看了其他的解决方案，说是把版本降到 4.x。但是呢，我想着作者已经用 ts 升级了依赖，为什么还要走老路呢。于是我干脆利落地卸载了 <code>@types/ioredis</code>。发现问题并没有解决，<strong>遇事不绝，重启 vscode</strong>。再次打开项目时，第一个问题真的解决好了。</p><p>第二个坑点：<br><code>error TS2339: Property &#39;userid&#39; does not exist on type &#39;Session &amp; Partial&lt;SessionData&gt;&#39;</code>, 这个问题一看就是定义的属性不存在于 <code>Seesion</code> 类型上面。但是这里我们需要把自定义的数据属性放到 <code>req.session</code> 对象上，就必须要用到自定义属性，怎么解决呢？去找了一些解决方案，发现可以使用 ts 的 <code>Declaring Merging</code> <strong>声明融合</strong>功能，为原先的类型扩充属性。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Session</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;express-session&quot;</span>;<br><br><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&quot;express-session&quot;</span> &#123;<br>    <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Session</span> &#123;<br>        <span class="hljs-attr">userid</span>: <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span>;<br>        <span class="hljs-attr">loadedCount</span>: <span class="hljs-built_in">number</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第三个坑点: 自定义的类型没有生效，查看了一些解决方案后，发现可以为 <code>tsconfig.json</code> 配置文件添加 <code>typeRoots</code> 属性值。<br>像这样</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&quot;typeRoots&quot;</span>: [<br>      <span class="hljs-string">&quot;./src/types&quot;</span>, <span class="hljs-regexp">//</span> this is where you define your types<br>       <span class="hljs-string">&quot;./node_modules/@types&quot;</span> <span class="hljs-regexp">//</span>this where npm packages containing types are located<br>    ],                                  <span class="hljs-regexp">/* Specify multiple folders that act like &#x27;./</span>node_modules<span class="hljs-regexp">/@types&#x27;. */</span><br></code></pre></td></tr></table></figure><p>定义了类型后，发现 vscode 的错误提示还是存在，没办法，再次重启。好了，红色波浪线不见了，但是命令行运行 <code>ts-node-dev --respawn src/index.ts</code> 还是报错, 属性不存在, 愁死我了。心想，<code>ts-node-dev</code> 是不是没有加载根目录的配置文件。看到启动 <code>ts-node-dev</code> 打印的 ts 版本与当前项目的 ts 版本不一致，让我觉得这样想准没错。找了半天文档，没看见啥命令行 options 可以打印当前的配置的。问题再度陷入了僵局，我左思右想，在 <code>ts-node-dev</code> 的 npm 仓库介绍，看到这样一句话</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">Tweaked <span class="hljs-keyword">version</span> of <span class="hljs-keyword">node</span><span class="hljs-title">-dev</span> that uses ts-<span class="hljs-keyword">node</span> <span class="hljs-title">under</span> the hood.<br></code></pre></td></tr></table></figure><p>是不是应该从 <code>ts-node</code> 寻找突破口。<br>果然让我发现了 <code>--showConfig</code> 可以打印配置信息，前往 vscode 终端一试，发现我自定义的类型文件是包含在里面的。也就是说，定义的配置文件是加载到了，问题又进入了僵局。<br>接着搜索名，看看其他人有什么解决方案。</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">By default, `ts-node` does <span class="hljs-literal">not</span> load `files`, `include` <span class="hljs-literal">or</span> `exclude` from `tsconfig.json` on startup. The `--files` option enables it.<br><br><span class="hljs-title">See &lt;https:</span>//github.com/TypeStrong/ts-node#missing-types&gt;<br></code></pre></td></tr></table></figure><p>终于破案了，这个坑太大了，谁能想得到。因为 <code>ts-node-dev</code> 是基于 <code>ts-node</code> 构建的，对于后者有效的配置，前者也有效。终于耗了我一整个下午的问题终于解决了。</p><p>第四个坑点:<br><code>TypeError: Class constructor RedisStore cannot be invoked without &#39;new&#39;</code>。问题还是出在教学示例使用的依赖版本偏低了。升级后的依赖做了 breaking changes。找到了官方发布的 <a href="https://github.com/tj/connect-redis/releases/tag/v7.0.0">release log</a>。重写了实例化 redisStore 的代码。现在一切正常了。</p><p>总结反思：学习编程就是这样不断的发现问题，解决问题的过程。解决问题的思路，会越来越开阔，随着对问题的刨析，也会越来越清晰。这就是编程的魅力啊。</p>]]></content>
    
    
    
    <tags>
      
      <tag>后端开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSH 远程登录要点解析</title>
    <link href="/blog/2024/03/08/SSH%20%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E8%A6%81%E7%82%B9%E8%A7%A3%E6%9E%90/"/>
    <url>/blog/2024/03/08/SSH%20%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E8%A6%81%E7%82%B9%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>最近打算学习一下 Node 源代码，在虚拟机上安装 Linux 的桌面版后，用 VSCODE 打开代码非常不方便，总是带着个虚拟机的外壳（VMware Workstation）。于是就想到用 VSCODE 的远程开发。按照<a href="https://juejin.cn/post/7176469208161747005">网上的教程</a>配置好 SSH 密钥后，现在可以非常顺滑的连接虚拟机了。步骤中涉及的要素有点多，想着写篇文章记录一下各个要素的关系。</p><p>涉及的要素有：<br><br>Host: Windows 10, SSH Client, known_hosts, config<br><br>Server: Ubuntu 22.04, SSH Server, authorized_keys</p><p>关系：<br><br>首先生成密钥对，SSH Client 和 SSH Server 使用密钥对进行通信。<br><br>而后，将生成的公钥 <code>id_rsa.pub</code> 内容放到 SSH Server 上的 <code>~/.ssh/authorized_keys</code> 文件里，注意它是文件，不是文件夹。<br><br><code>sudo reboot</code> 重启 SSH Server。<br>最后就可以用 <code>ssh -i ~/.ssh/你的私钥 username@remote_host</code> 登录 SSH Server（生成密钥的时候没有设置密钥，那就不需要输入密码）。<br>如果登录失败，又或是有其他问题，不符合预期，可以通过 <code>service sshd status</code> 查看登录日志，进一步了解情况。</p><p>其他：(from gpt)<br></p><ol><li>known_hosts: <ul><li>文件包含了远程服务器公钥的指纹。当 SSH Client 首次连接到一台新服务器的时候，它会将服务器的公钥添加到 known_hosts 文件中。</li><li>每当 SSH client 尝试连接到已知的主机时，它会使用 <code>known_hosts</code> 文件中的公钥指纹来验证服务器的身份。如果公钥指纹与 <code>known_hosts</code> 文件中的指纹匹配，连接将继续进行。</li><li>如果公钥指纹不匹配，SSH client 会警告用户可能存在中间人攻击，并询问用户是否仍然希望继续连接。</li></ul></li><li>config:（VSCODE会读取这个文件用于连接远程服务器）<ul><li>文件允许用户为 SSH 连接设置全局或特定于主机的选项。例如，你可以设置端口号、用户、身份文件、禁用密码认证等。</li><li>配置文件通常位于用户的家目录下的 <code>.ssh</code> 文件夹中。</li><li>例如，以下是一个配置文件的示例，它设置了一个特定主机的用户和身份文件。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Host remote_server<br>  User myuser<br>  HostName remote_host.com<br>  Port 2222<br>  IdentityFile ~/.ssh/mykey<br></code></pre></td></tr></table></figure></li></ul></li><li>authorized_keys:<ul><li>文件包含了一系列的公钥，这些公钥被服务器用来验证连接的客户端。</li><li>当客户端尝试通过 SSH 密钥认证连接到服务器时，它会发送其公钥。服务器会检查 <code>authorized_keys</code> 文件，看是否有匹配的公钥，然后使用该公钥对应的私钥进行验证。</li><li>如果在 <code>authorized_keys</code> 文件中找到了匹配的公钥，服务器将接受连接，并且允许客户端无密码登录。</li></ul></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>跨域解决方案</title>
    <link href="/blog/2022/05/29/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-2/"/>
    <url>/blog/2022/05/29/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-2/</url>
    
    <content type="html"><![CDATA[<ol><li><p>最推荐的方式：<strong>反向代理</strong></p><blockquote><p>什么是反向代理呢，站在客户端的角度，代理服务器的就是反向代理。客户端不知道自己连接的是那个服务器，都有代理服务器去决定转发的规则。</p><p>反向代理有诸多好处，比如：保障服务器的安全，因为它隐藏了真正的服务器端地址；负载均衡，通过转发策略向多个服务器进行请求转发；缓存静态内容；</p><p>最常用的反向代理服务器当属 Nginx.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">server &#123;<br>    listen              443 ssl;<br>    server_name         backend1.example.com;<br><br>    ssl_certificate     /etc/ssl/certs/server.crt;<br>    ssl_certificate_key /etc/ssl/certs/server.key;<br>    <span class="hljs-comment">#...</span><br>    location /yourapp &#123;<br>        proxy_pass http://url_to_app.com;<br>        <span class="hljs-comment">#...</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>​</p></blockquote></li><li><p>开发中使用的正向代理</p><blockquote><p>Webpack 构建的 Webpack-dev-server 插件支持代理的配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">devSeerver</span>: &#123;<br>  <span class="hljs-attr">proxy</span>: &#123;<br>    <span class="hljs-comment">// 以 /api 开头的请求会被转发到target 指定的地址</span><br>    <span class="hljs-string">&#x27;/api/&#x27;</span>: &#123;<br>      <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://localhost:8090&#x27;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​</p></blockquote></li><li><p>CORS (Cross-Origin Resource Sharing)</p><blockquote><p>这种跨域方式，将请求类型分为两种——简单请求和非简单请求，分别做出处理</p><p>浏览器发送请求的时候会在头部的 Origin 字段中带上本次的 “源” （协议+域名+端口）信息，服务器端会返回能够接受的源，“*” 表示接受任意源的请求。</p></blockquote></li><li><p>Websocket 解决跨域</p><blockquote><p>Websocket 和 HTTP 一样，也是基于 TCP 的一种网络协议，与 HTTP (HTTPS) 对应的是 WS (WSS)，对于 Websocket 没有同源限制。</p></blockquote></li><li><p>JSONP (JSON with Padding)</p><blockquote><p>虽然 AJAX 请求必须同源，但是对 样式、js资源文件的请求却可以是不同源的。</p><p>于是哦，可以通过 script 标签，向另一个服务器端请求文件时带上参数。然后，请求脚本文件后，执行脚本。脚本使用请求 url 中的参数，完成取数据的操作。</p></blockquote></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
      <tag>了不起的JavaScript工程师</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试题（一）</title>
    <link href="/blog/2022/01/14/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/blog/2022/01/14/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>H5新特性</p><ul><li>拖拽释放（Drap and drop) API ondrop</li><li>自定义属性 data-id</li><li><strong>语义化标签，header、nav、footer、aside、article、section</strong></li><li>音频自动播放属性 autoplay</li><li>画布 Canvas</li><li>离线存储 localStorage、会话存储 sessionStorage</li><li>表单控件，calendar、date、time、email、url、search</li><li>新技术，web worker、web socket、geolocation</li></ul><p>C3新特性</p><ul><li>颜色新增，RGBA、HSLA模式</li><li>文字阴影，text-shadow</li><li>盒模型，box-sizing</li><li>渐变，linear-gradient、radial-gradient</li><li>过度，transition <code>&lt;animation-name&gt;</code></li><li>自定义动画 animate @keyframe</li><li>媒体查询，@media screen and (max-width: 800px) { … }</li><li><strong>弹性布局，flex</strong></li></ul><p>H5浏览器存储有哪些</p><ul><li><strong>cookie，在控制台输入<code>document.cookie</code> 可以看到当前页面的cookie值，是一个字符串，以分号分隔</strong>，<code>&#39;_octo=GH1.1.647075200.1634350299; tz=Etc%2FGMT-8&#39;</code>。cookie 始终在同源的 http 请求中携带。</li><li>localStorage，本地化持久存储，只要用户不删除，就一直存在。在控制台输入<code>sessionStorage </code>得到 <code>Storage &#123;length: 0&#125;</code></li><li>sessionStorage，面向session 的浏览器存储，因此只存在于一个页面的生命周期内。在控制台输入<code>localStorage</code>得到 <code>Storage &#123;ref-selector:helloqingfeng/Awsome-Front-End-learning-resource:branch: &#39;&#123;&quot;refs&quot;:[&quot;master&quot;,&quot;gh-pages&quot;],&quot;cacheKey&quot;:&quot;v0:1472661172.0&quot;&#125;&#39;, ref-selector:baozouai/shop-admin:branch: &#39;&#123;...&#125;&#39;</code></li><li>indexedDB，<code>IDBFactory &#123;&#125;</code></li><li>window对象上的全局变量</li></ul><p>盒子水平垂直居中</p><ul><li><strong>margin: 0 auto;</strong></li><li>display: table-cell;</li><li><strong>display: flex; jusitify-content: center; align-items: center;</strong></li><li>.parent { position: relative } .child { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%)}</li></ul><p>CSS盒模型</p><ul><li>box model 指的是css 中所有元素都可以看作是一个个的盒子，包括内容、内边距、边框、外边距。</li><li>盒模型分两种<ul><li>w3c 标准盒模型，称为标准盒模型。<strong>height 属性指的是 content 内容区域的大小</strong></li><li>ie 标准盒模型，怪异盒模型。<strong>height 属性指的是 content+border+padding 的大小</strong></li></ul></li></ul><p>块级元素和行内元素的区别</p><ul><li><strong>块级元素占一行，填满父元素。可以设置 width、height、margin、padding 属性</strong></li><li>行内元素随着内容宽度变化而变化。自动换行。宽高无效，水平方向的margin、padding有效</li></ul><p>选择器权重</p><ul><li><code>!important &gt; 行内样式 &gt; ID 选择器 &gt; 类选择器、伪类、属性 &gt; 标签、伪元素 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</code></li><li>权重计算方式为选择符中ID <code>选择器的数量 x 100 + 类、伪类、伪元素的数量 x 10 + 标签、伪元素的数量</code>。<strong>div#app.child[name=”appName”] 的权重值为 a=1,b=2,c=1 ➡ 1+100+10x2 = 121</strong></li></ul><p>语义化标签</p><ul><li>利用html 的原生样式减少css 样式的书写。</li><li><strong>有利于SEO ，便于浏览器理解页面结构</strong></li><li>样式丢失的时候也能呈现较为清晰的页面结构</li><li>常见的语义化标签<ul><li><code>&lt;header&gt;</code> 、<code>&lt;section&gt;</code> 、<code>&lt;article&gt;</code> 、<code>&lt;aside&gt;</code> 、<code>&lt;footer&gt;</code></li></ul></li></ul><p>H5 事件举例</p><ul><li>通过 <code>on+&lt;事件名字&gt;</code> 的形式，作为元素的属性进行指定</li><li><strong>onblur 失去焦点、onchange 元素改变、onclick 单击鼠标</strong>、onkeydown 按下按键时候触发、onkeypress 按下并松开时触发、onkeyup 松开按键时触发。</li></ul><p>H5 input 元素 type 值举例</p><ul><li>button、checkbox、<strong>color 拾色器、date 日期字段、month 定义月、time 定义时间</strong>、email、file、hidden 隐藏输入字段、image 输入图像、number 带有微调spinner 控件的字段、password、radio、search、submit、text、url</li></ul><p>css 三角形制作</p><ul><li><strong>画三角形的实质是设置内容宽高为0，显示其中一条边界线</strong>。</li><li>.triangle { width: 0; height: 0; border 50px solid transparent; border-bottom: 100px solid green;}</li></ul><p>css 中的单位，px、em、rem</p><ul><li>px 像素，绝对单位，相对于显示器屏幕分辨率而言。是计算机系统的数字化图像长度单位</li><li>em 相对于当前元素内文本的字体尺寸</li><li><strong>rem 相对于根元素的字体尺寸</strong>， html 根元素默认 16px。</li></ul><p>display: none 和 visibility： hidden 区别</p><ul><li><strong>display: none 元素隐藏，占据的空间消失</strong></li><li>visibility： hidden 元素不可见，仍然占据页面空间</li></ul><p>position 属性的值有哪些</p><ul><li>static：元素默认值</li><li><strong>relative：相对于元素原来在文档流中的定位</strong></li><li><strong>absolute：相对于最近的非 static 定位祖先元素进行定位</strong></li><li>fixed：相对于相对于屏幕视口（viewport）的位置进行定位</li><li>sticky：相对它的最近滚动祖先和最近块级祖先进行定位</li></ul><p>雪碧图</p><ul><li><strong>将网站上用到的一些图片合并到一张图片上，通过减少网络请求来提高性能</strong>。</li><li>缺点，图片位置需要精确的指定，利用background、background-position 属性，增加了css 样式的编写难度。</li></ul><p>css3 新增伪类，伪元素</p><ul><li>:first-of-type 父元素的首个p元素、:last-of-type 最后的p元素</li><li><strong>:nth-child(n) 括号中表达式（an+b）匹配到的元素集合（n=0，1，2，3…），还有odd、even 可用</strong></li><li>:not(p) 非p元素、:enabled 表单控件的可用状态、:disabled 禁用表单控件、:checked 单选框或者复选框被选中。</li><li>::first-line 样式添加到文本的首字母，::first-line 样式添加到文本的首行。</li><li>低版本的IE中，不兼容双冒号，继续使用单冒号的伪元素。</li><li>伪元素一般指的是特殊位置，而伪类，是特殊状态</li></ul><p>图片懒加载原理</p><ul><li>核心是，监控图片位置，在合适的位置将其加载出来。</li><li>设置图片的data-set 属性，为图片的url。当图片的顶点坐标Y小于页面和浏览器高度时，将data-set 内url 属性赋值给src。涉及到的API包括obj.getBoundingClientRect().top;document.documentElement.clientHeight;</li></ul><p>JS 基本类型，引用类型</p><ul><li><strong>基本数据类型：number, string, boolean, null, undefined</strong></li><li>引用数据类型：function, object, Array</li><li>undefined 表示变量声明但是未初始化的值</li><li>null 表示准备用来保存对象，但还没有真正保存对象的值</li><li>undefined 派生至 null</li></ul><p>创建对象的几种方式</p><ul><li><strong>字面量对象， <code>let o1 = &#123; name: &#39;01&#39;&#125;</code></strong></li><li>new 一个对象，<code>let o2 = new Object(&#123; name: &#39;02&#39;&#125;)</code></li><li>显式的构造函数，<code>let o3 = function() &#123; this.name = &#39;03&#39;&#125;;</code></li><li>Object.create()，<code>let o = &#123; name: &#39;04&#39;&#125;; let o3 = Object.create(o)</code></li></ul><p>区分数组和对象</p><ul><li><strong>Array.isArray()，</strong><ul><li>Aarray.isArray([]) // true</li><li>Array.isArray({}) // false</li></ul></li><li><strong>instanceof，</strong><ul><li>[] instanceof Array // true</li><li>{} instanceof Array // false</li></ul></li><li>constructor，<ul><li>{}.constructor // 返回object</li><li>[].constructor // 返回Array</li></ul></li><li>Object.prototype.toString.call()，<ul><li>Object.prototype.toString.call([]) //[“object Array”]</li><li>Object.prototype.toString.call({}) // [“object Object”]</li></ul></li></ul><p>伪数组（类数组）转化</p><ul><li>伪数组具有length 属性，以及按照数组索引的方式存储数据。</li><li>转化方式<ul><li><strong>Array.from()</strong></li><li><strong>[].slice.call(eleArr) 或者 Array.prototype.slice.call(eleArr)</strong></li></ul></li></ul><p>遍历对象属性</p><ul><li>Object.keys() 可枚举，非继承属性。for…in 还包括继承的可枚举属性</li><li>Object.getOwnPropertyNames() 可枚举，不可枚举，非继承属性</li><li><strong>hasOwnProperty() 判断对象是否有某个属性</strong></li></ul><p>src 和 href 区别</p><ul><li>src (source) 资源，指向的内容会嵌入到标签所在位置，比如脚本，图片，iframe。解析到此类元素时。<strong>浏览器会暂停其他元素的下载和处理</strong>。知道将该元素加载、编译、执行完毕。</li><li>href (hypertext reference) 建立和当前元素的链接。会并行下载i资源，不会停止对当前文档的处理。</li></ul><p>dom 事件模型</p><ul><li><strong>元素发生一个事件，父元素也感受到了。那么就有了一个先后执行的问题。</strong></li><li>事件由根元素开始触发，向内传播 —— 事件捕获</li><li>事件由目标元素，一直传播到根元素 —— 事件冒泡</li><li>addEventListener 默认为事件冒泡机制</li><li>可以用 e.stopPropagation(); 或者 return false; 或者 e.preventDefault(); 停止事件在冒泡链上进一步扩大</li></ul><p>js 定时器</p><ul><li>setTimeout() —— 在指定毫秒数后运行函数，一般用来模拟异步操作。</li><li>setInterval() —— 按照设置的时间间隔运行函数，<strong>直到 clearInterval() 或者窗口被关闭</strong></li></ul><p>回调函数</p><ul><li>软件模块之间的接口，从调用方式上可以分为 3 类，<strong>同步调用、异步调用、回调</strong></li><li>同步调用就是通常所说的调用函数，一步一步执行，这是一种阻塞式调用，函数执行完毕才会返回。</li><li>异步调用，是一种类似于消息或者事件的机制。接口的服务在收到某种讯息或发生某种事件的时候，主动通知调用方。</li><li>回调函数就是一个通过函数指针调用的函数。把函数指针（地址）作为函数参数传递给另一个函数。</li></ul><p>什么是闭包</p><ul><li>闭包，closure，可以理解为一个封闭空间，一个定义在函数内部的函数。<strong>它可以通过作用域链访问外部函数的变量空间</strong>。</li><li>可以利用闭包的这个性质，保存外部变量，当然也会造成一些性能损失。</li></ul><p>原型的理解</p><ul><li>原型的作用是为了<strong>实现继承，和扩展对象的一种代码重用机制</strong>。</li><li>js 中的所有元素，都可以看作是对象，他们都有一个 prototype 属性，它的值是一个对象，叫做原型，这个prototype 属性又有自己的 prototype 属性。最终链接到 Object 对象。</li><li>prototype 属性，有一个 constructor 属性。可以用来构造对象的实例。</li></ul><p>说下 this</p><ul><li>this 是一个标识符，<strong>用来指代函数执行的上下文执行环境</strong>。</li><li>讲 this，就一定要说一下对象的构造机制。在构造对象的时候，this 赋值为一个Object 实例，然后向其中添加属性方法。那么，对这个对象内部的函数，this 可以在它的变量表中，找到 this 所指代的对象。</li><li>那么一般地调用对象内部的方法，this 就是 函数前面的对象。从对象可以找到函数，那么函数内部的this, 指的就是这个对象。</li><li>另一个函数回调，要通过apply、call 手动声明函数的执行上下文，this 指代的是什么。</li><li>箭头函数，没有自己的this, 它使用的是自己定义环境中的this 指代的对象。通过作用域链是使用this。</li></ul><p>统计出现最多的字符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123;&#125;; <span class="hljs-comment">// 先定义一个空对象,稍后使用.</span><br><span class="hljs-keyword">var</span> maxChar=<span class="hljs-string">&#x27;&#x27;</span>; <span class="hljs-comment">// 要输出的字符</span><br><span class="hljs-keyword">var</span> maxN=<span class="hljs-number">0</span>;<span class="hljs-comment">// 字符数量</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-property">length</span>; i++) &#123; <span class="hljs-comment">//   循环字符串中每一项</span><br>    <span class="hljs-keyword">var</span> k = str[i]; <span class="hljs-comment">// 把每一项保存给变量 k (对这一步不理解可先熟悉 for循环机制);</span><br><br>    <span class="hljs-keyword">if</span> (obj[k]) &#123;<br><br>        obj[k]++;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        obj[k] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(obj[k]&gt;maxN)&#123;<br>        maxChar=k;<br>        maxN=obj[maxChar];<br>    &#125;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(maxChar, maxN);<br></code></pre></td></tr></table></figure><p>内存泄漏</p><ul><li>一些不再使用的变量，依然占据着内存空间，称为内存泄漏，（浪费掉了）</li></ul><p>事件循环</p><ul><li>js 是一个单线程的语言。这意味着同一时间只能做一件事。</li><li>单线程不意味着阻塞，<strong>实现单线程非阻塞的方法是事件循环</strong>。</li><li>js 中的任务可以分为同步任务和异步任务<ul><li>同步任务就是立即执行的任务，会直接进入到主线程中执行</li><li>异步任务，异步执行的任务，比如ajax网络请求，setTimeout 定时函数</li><li>同步任务执行完毕，就会去任务队列中的任务，推入主线程执行。</li></ul></li><li>异步任务又分为宏任务和微任务<ul><li>执行机制为执行完宏任务后，执行所有微任务。再进行查看是有宏任务</li><li>常见的微任务有，Promise.then，MutationObserver，process.nextTick</li></ul></li></ul><p>Promise</p><ul><li>promise 是一个有状态的对象</li><li>将异步操作的结果和对应的处理函数结合起来</li><li>将异步操作以同步操作的流程表达出来，避免回调地狱</li><li>Promise 的构造函数接收一个回调，回调有两个参数 <code>resolve reject</code>，成功就调用resolve，表示promise 状态fulled，结果为resolve 返回的结果。实例化的Promise，返回的对象可以调用 then()  方法，then()  方法接收两个参数，onResolve 和 onReject 对应promise 成功或者失败的状态</li></ul><p>手写 Promise</p><ul><li><p>```js<br>class Promise {</p><pre><code class="hljs">constructor(handler) &#123;    // define initial state    this.status = &quot;pending&quot;;    this.onFulfilledCallbacks = [];    this.onRejectedCallbacks = [];        // define basic transition function    const resolve = value =&gt; &#123;        if (this.status === &quot;pending&quot;) &#123;            this.status = &quot;fulfilled&quot;;            this.value = value;            this.onFulfilledCallbacks.forEach(fn =&gt; fn(value));        &#125;    &#125;;    const reject = value =&gt; &#123;        if (this.status === &quot;pending&quot;) &#123;            this.status = &quot;rejected&quot;;            this.value = value;            this.onRejectedCallbacks.forEach(fn =&gt; fn(value));        &#125;    &#125;;    try &#123;        // call outer function passed in        handler(resolve, reject);    &#125; catch (err) &#123;        reject(err);    &#125;&#125;then(onFulfilled, onRejected) &#123;    // support chain call    return new Promise((resolve, reject) =&gt; &#123;        // define handler        if (this.status === &quot;pending&quot;) &#123;            this.onFulfilledCallbacks.push(() =&gt; &#123;                try &#123;                    // if return value is promise, resolve it.                    const fulfilledFromLastPromise = onFulfilled(this.value);                    if (fulfilledFromLastPromise instanceof Promise) &#123;                        fulfilledFromLastPromise.then(resolve, reject);                    &#125; else &#123;                        resolve(fulfilledFromLastPromise);                    &#125;                &#125; catch (err) &#123;                    reject(err);                &#125;            &#125;);            this.onRejectedCallbacks.push(() =&gt; &#123;                try &#123;                    const rejectedFromLastPromise = onRejected(this.value);                    if (rejectedFromLastPromise instanceof Promise) &#123;                        rejectedFromLastPromise.then(resolve, reject);                    &#125; else &#123;                        reject(rejectedFromLastPromise);                    &#125;                &#125; catch (err) &#123;                    reject(err);                &#125;            &#125;);        &#125;        if (this.status === &quot;fulfilled&quot;) &#123;            try &#123;                const fulfilledFromLastPromise = onFulfilled(this.value);                if (fulfilledFromLastPromise instanceof Promise) &#123;                    fulfilledFromLastPromise.then(resolve, reject);                &#125; else &#123;                    resolve(fulfilledFromLastPromise);                &#125;            &#125; catch (err) &#123;                reject(err);            &#125;        &#125;        if (this.status === &quot;rejected&quot;) &#123;            try &#123;                const rejectedFromLastPromise = onRejected(this.value);                if (rejectedFromLastPromise instanceof Promise) &#123;                    rejectedFromLastPromise.then(resolve, reject);                &#125; else &#123;                    reject(rejectedFromLastPromise);                &#125;            &#125; catch (err) &#123;                reject(err);            &#125;        &#125;    &#125;);&#125;</code></pre><p>}</p><p>// testing code<br>let p1 = new Promise((resolve, reject) =&gt; {</p><pre><code class="hljs">setTimeout(() =&gt; resolve(&#39;resolved first one&#39;), 1000);</code></pre><p>});<br>p1.then((res) =&gt; {</p><pre><code class="hljs">console.log(res);return new Promise(resolve =&gt; &#123;    setTimeout(() =&gt; resolve(&#39;resolved second one&#39;), 1000);&#125;);</code></pre><p>}).then(res =&gt; {</p><pre><code class="hljs">console.log(res);</code></pre><p>});</p><p>// 1 sec later, ‘resolved first one’<br>// 1 sec later, ‘resolved second one’</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><br>实现 <span class="hljs-built_in">Promise</span>.all, <span class="hljs-built_in">Promise</span>.race, <span class="hljs-built_in">Promise</span>.resolve <span class="hljs-keyword">and</span> <span class="hljs-built_in">Promise</span>.reject<br><br>- ```<span class="language-javascript">js</span><br><span class="language-javascript">  <span class="hljs-title class_">Promise</span>.<span class="hljs-property">all</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">promises</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">          <span class="hljs-keyword">let</span> counter = <span class="hljs-number">0</span>;</span><br><span class="language-javascript">          <span class="hljs-keyword">const</span> result = [];</span><br><span class="language-javascript">          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; promises.<span class="hljs-property">length</span>; i++) &#123;</span><br><span class="language-javascript">              <span class="hljs-comment">// resolve revery promise, return result when every resolved</span></span><br><span class="language-javascript">              <span class="hljs-comment">// when reject, return reject(err)</span></span><br><span class="language-javascript">              <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(promises[i]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;</span><br><span class="language-javascript">                  result[i] = res;</span><br><span class="language-javascript">                  counter += <span class="hljs-number">1</span>;</span><br><span class="language-javascript">                  <span class="hljs-comment">// this check need to be here, otherwise counter would remain 0 till forloop is done</span></span><br><span class="language-javascript">                  <span class="hljs-keyword">if</span> (counter === promises.<span class="hljs-property">length</span>) &#123;</span><br><span class="language-javascript">                      <span class="hljs-title function_">resolve</span>(result);</span><br><span class="language-javascript">                  &#125;</span><br><span class="language-javascript">              &#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;</span><br><span class="language-javascript">                  <span class="hljs-title function_">reject</span>(err);</span><br><span class="language-javascript">              &#125;);</span><br><span class="language-javascript">          &#125;</span><br><span class="language-javascript">      &#125;);</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript">  </span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> promise1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>);</span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> promise2 = <span class="hljs-number">42</span>;</span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> promise3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">100</span>, <span class="hljs-string">&#x27;foo&#x27;</span>);</span><br><span class="language-javascript">  &#125;);</span><br><span class="language-javascript">  </span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> newPromise = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([promise1, promise2, promise3]).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">values</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(values);</span><br><span class="language-javascript">  &#125;);</span><br><span class="language-javascript">  </span><br><span class="language-javascript">  <span class="hljs-comment">// after 100ms, output:  Array [3, 42, &quot;foo&quot;]</span></span><br></code></pre></td></tr></table></figure></li><li><p>```js<br>Promise.race = function (promises) {</p><pre><code class="hljs">return new Promise((resolve, reject) =&gt; &#123;    for (let p of promises) &#123;        // iterate every promise, return the first one        Promise.resolve(p).then(res =&gt; resolve(res), err =&gt; reject(err));    &#125;&#125;);</code></pre><p>}</p><p>// testing<br>const promise1 = new Promise((resolve, reject) =&gt; {</p><pre><code class="hljs">setTimeout(resolve, 500, &#39;one&#39;);</code></pre><p>});<br>const promise2 = new Promise((resolve, reject) =&gt; {</p><pre><code class="hljs">setTimeout(resolve, 100, &#39;two&#39;);</code></pre><p>});<br>Promise.race([promise1, promise2]).then((value) =&gt; {</p><pre><code class="hljs">console.log(value);// Both resolve, but promise2 is faster</code></pre><p>}, err =&gt; console.log(err));<br>// expected output: “two”</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><br>- ```<span class="language-javascript">js</span><br><span class="language-javascript">  <span class="hljs-title class_">Promise</span>.<span class="hljs-property">resolve</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) &#123;</span><br><span class="language-javascript">          <span class="hljs-keyword">return</span> value;</span><br><span class="language-javascript">      &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="language-javascript">          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">              <span class="hljs-title function_">resolve</span>(value);</span><br><span class="language-javascript">          &#125;);</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript">  </span><br><span class="language-javascript">  <span class="hljs-title class_">Promise</span>.<span class="hljs-property">reject</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">reason</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> <span class="hljs-title function_">reject</span>(reason));</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">  </span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve1</span>(<span class="hljs-string">&quot;Success&quot;</span>);</span><br><span class="language-javascript">  p1.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)); <span class="hljs-comment">// &quot;Success&quot;</span></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> p2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject1</span>(<span class="hljs-string">&quot;No&quot;</span>); </span><br><span class="language-javascript">  p2.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> &#123; &#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err)); <span class="hljs-comment">// &quot;No&quot;</span></span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>知识总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Express Middleware 的简易实现</title>
    <link href="/blog/2022/01/09/express-middleware%E7%AE%80%E6%98%93%E5%AE%9E%E7%8E%B0/"/>
    <url>/blog/2022/01/09/express-middleware%E7%AE%80%E6%98%93%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>原文地址：<a href="https://programmer.ink/think/simple-implementation-principle-of-express-middleware.html">Simple implementation principle of Express Middleware</a></p><p>简而言之，express 中间件，就是在服务器端处理<strong>请求对象</strong>和<strong>响应对象</strong>的函数。</p><p>遵循一个先注册，先执行的原则，通过调用<code>next()</code>函数，把执行权交给下一个函数。</p><p>核心代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">next</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> stack = stacks.<span class="hljs-title function_">shift</span>();<br>    <span class="hljs-keyword">if</span>(stack) &#123;<br>        <span class="hljs-title function_">stack</span>(req, res, next);<br>    &#125;<br>&#125;<br><span class="hljs-title function_">next</span>();<br></code></pre></td></tr></table></figure><p>express 简易实现的代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br><span class="hljs-keyword">const</span> slice = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span><br><br> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Express</span> &#123;<br>     <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">router</span> = &#123;<br>            <span class="hljs-attr">all</span>: [], <span class="hljs-comment">// Match all middleware functions</span><br>            <span class="hljs-attr">get</span>: [],<br>            <span class="hljs-attr">post</span>: []<br>        &#125;<br>     &#125;<br><br>     <span class="hljs-comment">/**</span><br><span class="hljs-comment">      * Integrate middleware here</span><br><span class="hljs-comment">      * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; path </span><br><span class="hljs-comment">      * <span class="hljs-doctag">@returns</span> &#123;<span class="hljs-type">object</span>&#125;</span><br><span class="hljs-comment">      */</span><br>     <span class="hljs-title function_">middlewareHandler</span>(<span class="hljs-params">path</span>) &#123;<br>        <span class="hljs-keyword">const</span> info = &#123;&#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> path === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>            <span class="hljs-comment">// by use()、get()、post()、pass into &lt;path&gt; and &lt;handler&gt;</span><br>            <span class="hljs-comment">// 如果包含路劲参数，那么第二个参数开始才是中间件函数</span><br>            info.<span class="hljs-property">path</span> = path<br>            info.<span class="hljs-property">stack</span> = slice.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>, <span class="hljs-number">1</span>)  <span class="hljs-comment">// Middleware array</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 只传进去中间件函数，那么全部是handler.</span><br>            info.<span class="hljs-property">path</span> = <span class="hljs-string">&#x27;/&#x27;</span><br>            info.<span class="hljs-property">stack</span> = slice.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>, <span class="hljs-number">0</span>)<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> info<br>     &#125;<br><br>     <span class="hljs-title function_">use</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">const</span> allStack = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">middlewareHandler</span>(...<span class="hljs-variable language_">arguments</span>)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">router</span>.<span class="hljs-property">all</span>.<span class="hljs-title function_">push</span>(allStack)<br>     &#125;<br><br>     <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">const</span> getStack = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">middlewareHandler</span>(...<span class="hljs-variable language_">arguments</span>)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">router</span>.<span class="hljs-property">get</span>.<span class="hljs-title function_">push</span>(getStack)<br>     &#125;<br><br>     <span class="hljs-title function_">post</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">const</span> postStack = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">middlewareHandler</span>(...<span class="hljs-variable language_">arguments</span>)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">router</span>.<span class="hljs-property">post</span>.<span class="hljs-title function_">push</span>(postStack)<br>     &#125;<br><span class="hljs-comment">// 通过按照 方法 分类，建立 路径 到 处理函数 的映射</span><br>      <span class="hljs-comment">/**</span><br><span class="hljs-comment">       * </span><br><span class="hljs-comment">       * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; method </span><br><span class="hljs-comment">       * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">url</span></span><br><span class="hljs-comment">       * <span class="hljs-doctag">@returns</span> &#123;<span class="hljs-type">Array</span>&#125; </span><br><span class="hljs-comment">       */</span><br>     <span class="hljs-title function_">accordStack</span>(<span class="hljs-params">method, url</span>) &#123;<br>        <span class="hljs-keyword">let</span> stacks = []<br>        stacks = stacks.<span class="hljs-title function_">concat</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">router</span>.<span class="hljs-property">all</span>)<br>        stacks = stacks.<span class="hljs-title function_">concat</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">router</span>[method])<br>        <span class="hljs-keyword">return</span> stacks<br>        .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">stack</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">return</span> url.<span class="hljs-title function_">indexOf</span>(stack.<span class="hljs-property">path</span>) !== -<span class="hljs-number">1</span><br>        &#125;).<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">stack</span>[<span class="hljs-number">0</span>]) <span class="hljs-comment">// 这里有点问题，不应该只传进去第一个handler.</span><br>     &#125;<br><br>     <span class="hljs-title function_">handler</span>(<span class="hljs-params">req, res, stacks</span>) &#123;<br>         <span class="hljs-comment">// Function expression</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-title function_">next</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>            <span class="hljs-keyword">const</span> stack = stacks.<span class="hljs-title function_">shift</span>()<br>            <span class="hljs-keyword">if</span>(stack) &#123;<br>                <span class="hljs-title function_">stack</span>(req, res, next)<br>            &#125;<br>        &#125;<br>        <span class="hljs-title function_">next</span>()<br>     &#125;<br><br>     <span class="hljs-title function_">callback</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>            res.<span class="hljs-property">json</span> = <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>                res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;application/json&#x27;</span>)<br>                res.<span class="hljs-title function_">end</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data))<br>            &#125;<br>            <br>            <span class="hljs-comment">// Get the request method and url, and filter the middleware functions</span><br>            <span class="hljs-keyword">const</span> &#123;method, url&#125; = req<br>            <span class="hljs-keyword">const</span> stacks = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">accordStack</span>(method.<span class="hljs-title function_">toLowerCase</span>(), url)<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handler</span>(req, res, stacks)<br>        &#125; <br>     &#125;<br><br>     <span class="hljs-title function_">listen</span>(<span class="hljs-params">...args</span>) &#123;<br>         <span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">callback</span>())<br>         server.<span class="hljs-title function_">listen</span>(...args)<br>     &#125;<br> &#125;<br><br> <span class="hljs-comment">// Factory mode, export an instance object</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Express</span>()<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>知识总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>require 是什么</title>
    <link href="/blog/2022/01/09/require-%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <url>/blog/2022/01/09/require-%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<p>原文地址：<a href="https://nodejs.org/en/knowledge/getting-started/what-is-require/">What is require?</a></p><p>Nodejs 遵循 CommonJS 模块系统规则，内置的<code>require</code> 函数，是引入模块最简单的方法。<code>require</code> 基础功能是读取 Javascript 文件，执行文件，然后返回<code>exports</code> 对象。例子如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;evaluating example.js&quot;</span>);<br><br><span class="hljs-keyword">var</span> invisible = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;invisible&quot;</span>);<br>&#125;<br><br><span class="hljs-built_in">exports</span>.<span class="hljs-property">message</span> = <span class="hljs-string">&quot;hi&quot;</span>;<br><br><span class="hljs-built_in">exports</span>.<span class="hljs-property">say</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">exports</span>.<span class="hljs-property">message</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果运行 <code>let example = require(&#39;./example.js&#39;)</code> , example.js 被计算求值，example 等于：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;hi&quot;</span>,<br>  <span class="hljs-attr">say</span>: [<span class="hljs-title class_">Function</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p>如果要将 <code>exports</code> 对象设置为函数或新对象，则必须使用 <code>module.exports</code> 对象。举个例子:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;hello world&quot;</span>)<br>&#125;<br><br><span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./example2.js&#x27;</span>)() <span class="hljs-comment">//require itself and run the exports object</span><br></code></pre></td></tr></table></figure><p>值得注意的是，每当您随后需要一个已经需要的文件时，导出对象都会被缓存并重用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">node&gt; require(<span class="hljs-string">&#x27;./example.js&#x27;</span>)<br>evaluating example.js<br>&#123; message: <span class="hljs-string">&#x27;hi&#x27;</span>, say: [Function] &#125;<br>node&gt; require(<span class="hljs-string">&#x27;./example.js&#x27;</span>)<br>&#123; message: <span class="hljs-string">&#x27;hi&#x27;</span>, say: [Function] &#125;<br>node&gt; require(<span class="hljs-string">&#x27;./example.js&#x27;</span>).message = <span class="hljs-string">&quot;hey&quot;</span> //set the message to <span class="hljs-string">&quot;hey&quot;</span><br><span class="hljs-string">&#x27;hey&#x27;</span><br>node&gt; require(<span class="hljs-string">&#x27;./example.js&#x27;</span>) //One might think that this <span class="hljs-string">&quot;reloads&quot;</span> the file...<br>&#123; message: <span class="hljs-string">&#x27;hey&#x27;</span>, say: [Function] &#125; //...but the message is still <span class="hljs-string">&quot;hey&quot;</span> because of the module cache.<br></code></pre></td></tr></table></figure><p>从上面可以看到，example.js 是第一次计算的，但是所有后续调用都只需要调用模块缓存，而不是再次读取文件。如上所述，这偶尔会产生副作用。</p><p>require 查找文件的规则可能有点复杂，但一个简单的经验法则是，如果文件不以 “./“ 或 “/“，那么它要么被视为核心模块(并检查本地 Node.js 路径) ，要么被视为本地 node _ modules 文件夹中的依赖项。如果文件以 “./“  开头。它被认为是调用 require 的文件的相对文件。如果文件以 “/“ 开头，则认为它是绝对路径。注意: 你可以省略 “.js” 。如果需要的话，会自动添加。有关更多详细信息，请参阅官方文档。</p><p>另外需要注意的是：如果传递的文件名实际上是一个目录，那么它将首先在目录中查找 package.json 并加载 main 属性中引用的文件。否则，它将查找 index.js。</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ipconfig 信息解读</title>
    <link href="/blog/2021/12/29/ipconfig-%E4%BF%A1%E6%81%AF%E8%A7%A3%E8%AF%BB/"/>
    <url>/blog/2021/12/29/ipconfig-%E4%BF%A1%E6%81%AF%E8%A7%A3%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<p>因为有手机端调试网页的需求，于是找了一下手机端如何连接PC 端服务器方法。</p><p>之前解决过一次，因为没弄清楚原理，现在又忘了。</p><p>解决方案是：手机端浏览器地址栏输入<strong>无线网适配器的IPv4地址</strong>，对应的文件名也需要输入。</p><p>具体原理如下：</p><p>打开 <code>cmd</code> 命令行提示符窗口，</p><p>运行 <code>ipconfig</code>， 得到网络连接的相关信息。<code>ipconfig /all</code> 可以看到更加详细的信息。</p><p>首先了解一个概念，计算机是通过网卡，这个硬件来跟计算机网络系统来进行通讯的。网卡，又叫适配器，有一个类似于身份证一样的东西，唯一标识符，叫做<strong>物理地址：12个十六进制数，正好48位</strong>。</p><p>那么在PC 端所在的局域网中，每一个网络终端都会有一个IPv4 地址，用来进行通讯，数据的发送与接收。这个地址就是网卡和别的网卡进行通讯的标识符。手机与电脑通过WiFi 进行交互，也就是访问电脑端的<strong>无线网卡IPv4地址</strong>。</p><p>同理可得，以太网适配器中的IPv4 地址，就是和路由器网关进行通讯的标识符。</p><p>关于子网掩码：<a href="https://www.zhihu.com/question/56895036">如何理解子网掩码？</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>知识总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>思考学习方法</title>
    <link href="/blog/2021/12/28/%E6%80%9D%E8%80%83%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    <url>/blog/2021/12/28/%E6%80%9D%E8%80%83%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>为什么读那么多理论教程，不如实际操作一番，来得更加印象深刻呢？</p><p>因为现实世界是复杂的，语言文字对事物的描述，是对事物的一个基本面的快照，很难让你构建起一个事物的框架。于是所学过的知识点，便成了碎片信息，不便于存储利用。</p><p>大脑不擅长记忆存储信息，而擅长观察事物之间的联系。所以，知识点，如果不能形成一个良好检索的结构，比如树形，拓扑形，那么在需要检索它的时候，便会遇到很多阻碍，“记不住” 的现象也就随之发生了。</p><p>所以，符合大脑记忆规律的学习方法就是，理论和实践相结合。</p><p>话说了很多遍了，但还是要重复一次。</p><p>先理论，获取认知的基础点。比如 ts 是什么，解决了什么样的问题？</p><p>再实践，搭建起整体的架构。比如，在算法题中使用 ts, 做一下类型体操</p><p>紧接着，基于实践中的需要，开发具体的项目…</p><p>深入理论的学习，类型理论，自动推导…</p><p>在理论的扩展中，扩大实践活动。高手进阶之路</p>]]></content>
    
    
    
    <tags>
      
      <tag>方法总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git 全链路分析</title>
    <link href="/blog/2021/12/28/git-%E5%85%A8%E9%93%BE%E8%B7%AF%E5%88%86%E6%9E%90/"/>
    <url>/blog/2021/12/28/git-%E5%85%A8%E9%93%BE%E8%B7%AF%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>本文将对 git 的日常使用，做一个全链路的分析，结合文档，做一个细致描述。</p><p>首先，在脑海中，准备基础概念：</p><p>在自己电脑上的环境称为<code>local</code> 本地环境，<code>remote repo</code> 远程仓库 是在github的服务器上。</p><p>本地环境又有三个位置：分别是 <code>工作目录</code> 又被称为工作区、工作树，<code>暂存区</code> 又被称为索引区，<code>本地仓库</code>。</p><p>了解基本概念后，开始进行操作，注意 git 是一个分布式版本控制系统，一切都为追踪管理文件而生。</p><p><img src="https://user-images.githubusercontent.com/43318823/147582097-e2acd0db-2fa5-43b2-9223-c0edda81030f.png"></p><p>当我们初始化一个 git 仓库后，也就开启了 git 使用之旅。</p><p><code>git init</code> 创建一个 git 仓库，或者重新初始化一个已存在的仓库。想象一下，你有一个仓库，有货物没货物，你都可以派一个<strong>仓库管理员</strong>去管理它。</p><p>当你对本地目录做了一些操作之后，比如增加文件、删除文件、给文件增加内容、删减内容，此时，你可以用<code>git add &lt;file&gt;</code> 来将操作的内容保存为一个快照（不管干了啥，通通看作是一个对象obj，有个标志符可以让你操作它），进行<strong>追踪 track，也叫做 staged</strong>。 一般地，可以使用 <code>git add .</code> 或者 <code>git add -A</code> 进行全部更改的追踪。</p><p>现在你可以用 <code>git status</code> 来查看追踪的状态。(使用<code>git restore --staged &lt;file&gt;...</code> 取消追踪)</p><p>接下来，就可以进行提交操作，提交到本地仓库中去。使用的命令是<code>git commit -m &lt;msg&gt;</code> msg 的内容为log 信息，必须要写的。</p><p>git add 和 git commit 的操作，合并了就是 <code>git commit -am &lt;msg&gt;</code></p><p>现在，目光来到本地仓库。</p><p><code>git push</code> 将本地仓库的提交，推送到远程仓库。第一次推送，要指明仓库名和分支 <code>git push &lt;remote&gt; &lt;branch&gt;</code></p><p>完成从本地到远程的操作后，来看一下从远程到本地仓库的操作。</p><p><code>git clone</code> 将远程仓库，克隆到本地目录。</p><p><code>git pull</code> 获取远程仓库的更新，是<code>git push</code> 的逆向操作。</p><p>以上就是git 的日常使用命令。<code>git init</code> 初始化建仓库; <code>git commit -am &lt;msg&gt;</code> 提交到本地仓库; <code>git push</code>推送到远程仓库；</p><p><code>git pull</code> 从远程仓库拉取更新，是<code>git push</code> 的逆向操作；<code>git clone</code> 下载一个仓库到本地；</p><p>总之，要把每次对文件的操作看作是一个整体，进行相关操作。具体需要用到的命令也可以现用现查。</p><p>进一步学习：</p><ul><li><a href="https://ndpsoftware.com/git-cheatsheet.html#loc=index;">git 可视化工具</a></li><li><a href="https://learngitbranching.js.org/">Learn Git Branching</a></li><li><a href="https://onlywei.github.io/explain-git-with-d3">Explain Git With D3</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>知识总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>html未占满全屏</title>
    <link href="/blog/2021/12/28/html%E6%9C%AA%E5%8D%A0%E6%BB%A1%E5%85%A8%E5%B1%8F/"/>
    <url>/blog/2021/12/28/html%E6%9C%AA%E5%8D%A0%E6%BB%A1%E5%85%A8%E5%B1%8F/</url>
    
    <content type="html"><![CDATA[<p>解决 html, body 元素未占满全屏的问题</p><p>设置</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span>, <span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span><br>&#125;<br></code></pre></td></tr></table></figure><p>后，并没有解决问题。</p><p>因为浏览器默认按照窗口大小（viewport）来设置 html 元素大小。于是，当页面缩小的时候，html 变小，但是页面元素的尺寸是写死的，于是越界，侧边出现白边。</p><p>解决办法是设置</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span>, <span class="hljs-selector-tag">body</span> &#123;<br><span class="hljs-attribute">min-width</span>: <span class="hljs-number">1400px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>就是设置最小宽度，使得 html 元素包含内部元素。不随着窗口大小改变到最小值以下。</p>]]></content>
    
    
    
    <tags>
      
      <tag>bug fix</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法——生成独一无二的标识符</title>
    <link href="/blog/2021/12/16/%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E7%94%9F%E6%88%90%E7%8B%AC%E4%B8%80%E6%97%A0%E4%BA%8C%E7%9A%84%E6%A0%87%E8%AF%86%E7%AC%A6/"/>
    <url>/blog/2021/12/16/%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E7%94%9F%E6%88%90%E7%8B%AC%E4%B8%80%E6%97%A0%E4%BA%8C%E7%9A%84%E6%A0%87%E8%AF%86%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="153-uglify-CSS-class-names"><a href="#153-uglify-CSS-class-names" class="headerlink" title="153. uglify CSS class names"></a>153. uglify CSS class names</h1><p>如果你在项目中使用了<a href="https://github.com/webpack-contrib/css-loader">css-loader</a>， 你可以像这样通过<code>localIdentName</code>来变换class name。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">localIdentName</span>: <span class="hljs-string">&quot;[path][name]__[local]--[hash:base64:5]&quot;</span>,<br></code></pre></td></tr></table></figure><p>你也可以传入自定义的<code>getLocalIdent</code>函数来自由生成class name。</p><p><strong>请完成一个class name生成函数</strong> 并满足以下要求</p><ol><li>仅使用字母: <code>a</code> - <code>z</code> , <code>A</code> - <code>Z</code></li><li>调用一次返回一个类名</li><li>返回的类名序列需要满足: 先短后长，相同长度按照字母排序（小写字母优先）</li><li>同时提供一个reset函数</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">getUniqueClassName</span>()<br><span class="hljs-comment">// &#x27;a&#x27;</span><br><br><span class="hljs-title function_">getUniqueClassName</span>()<br><span class="hljs-comment">// &#x27;b&#x27;</span><br><br><span class="hljs-title function_">getUniqueClassName</span>()<br><span class="hljs-comment">// &#x27;c&#x27;</span><br><br><span class="hljs-comment">// skip cases till &#x27;Y&#x27;</span><br><br><span class="hljs-title function_">getUniqueClassName</span>()<br><span class="hljs-comment">// &#x27;Z&#x27;</span><br><br><span class="hljs-title function_">getUniqueClassName</span>()<br><span class="hljs-comment">// &#x27;aa&#x27;</span><br><br><span class="hljs-title function_">getUniqueClassName</span>()<br><span class="hljs-comment">// &#x27;ab&#x27;</span><br><br><span class="hljs-title function_">getUniqueClassName</span>()<br><span class="hljs-comment">// &#x27;ac&#x27;</span><br><br><span class="hljs-comment">// skip more cases</span><br><br><span class="hljs-title function_">getUniqueClassName</span>()<br><span class="hljs-comment">// &#x27;ZZ&#x27;</span><br><br><span class="hljs-title function_">getUniqueClassName</span>()<br><span class="hljs-comment">// &#x27;aaa&#x27;</span><br><br><span class="hljs-title function_">getUniqueClassName</span>()<br><span class="hljs-comment">// &#x27;aab&#x27;</span><br><br><span class="hljs-title function_">getUniqueClassName</span>()<br><span class="hljs-comment">// &#x27;aac&#x27;</span><br><br>getUniqueClassName.<span class="hljs-title function_">reset</span>()<br><br><span class="hljs-title function_">getUniqueClassName</span>()<br><span class="hljs-comment">// &#x27;a&#x27;</span><br></code></pre></td></tr></table></figure><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-keyword">let</span> id = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">const</span> chars = <span class="hljs-string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span>;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> &#123;<span class="hljs-type">string</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getUniqueClassName</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// your code here</span><br>  <span class="hljs-keyword">let</span> className = <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-keyword">let</span> num = id++;<br>  <span class="hljs-keyword">while</span>(num &gt;= <span class="hljs-number">0</span>) &#123;<br>    className = chars[num % chars.<span class="hljs-property">length</span>] + className; <span class="hljs-comment">// 通过余数获取当前字符， 理解为52进制转为十进制</span><br>    num = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(num / chars.<span class="hljs-property">length</span>) - <span class="hljs-number">1</span>; <span class="hljs-comment">// 长短</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> className;<br>&#125;<br><br>getUniqueClassName.<span class="hljs-property">reset</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// your code here</span><br>  id = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>package.json 文件中的软件包版本</title>
    <link href="/blog/2021/11/27/package-json-%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%89%88%E6%9C%AC/"/>
    <url>/blog/2021/11/27/package-json-%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%89%88%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<p><a href="https://semver.org/lang/zh-CN/">语义化版本 2.0.0</a></p><p>版本格式：主版本号.次版本号.修订号，版本号递增规则如下：</p><ol><li>主版本号：当你做了<strong>不兼容的 API 修改</strong>，</li><li>次版本号：当你做了<strong>向下兼容的功能性新增</strong>，</li><li>修订号：当你做了<strong>向下兼容的问题修正</strong>。</li></ol><p>先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸。</p><p><a href="https://www.jianshu.com/p/6061186a2733">package.json中版本号详解~和^和*的区别</a></p><ol><li><code>~</code> 匹配<strong>最新的次版本号</strong>(不包括)，**~1.15.2 :=  &gt;=1.15.2 &lt;1.16.0**   </li><li><code>^</code> 匹配<strong>最新的主版本号</strong>(不包括)，<strong>^3.3.4 := &gt;=3.3.4 &lt;4.0.0</strong></li><li><code>*</code> 匹配<strong>最新版本</strong>即可</li></ol><blockquote><p>所以建议使用~来标记版本号，这样可以保证项目不会出现大的问题，也能保证包中的小bug可以得到修复。</p><p>或者版本号写*，这意味着安装最新版本的依赖包，但缺点同上，可能会造成版本不兼容，慎用！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>小知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>npm命令行参数</title>
    <link href="/blog/2021/11/25/npm%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0/"/>
    <url>/blog/2021/11/25/npm%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p><a href="https://docs.npmjs.com/">npm Docs</a></p><p>本文将介绍 <code>npm CLI</code> 即 npm 命令行 常用操作参数的含义，给他们做一个汇总。</p><p>概要：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm &lt;<span class="hljs-built_in">command</span>&gt; [args]<br></code></pre></td></tr></table></figure><h2 id="npm-init"><a href="#npm-init" class="headerlink" title="npm init"></a>npm init</h2><p><code>npm iniy &lt;iniyializer&gt;</code> 用来初始化一个npm 包。</p><p>e.g. 创建一个 esm 兼容的包，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">mkdir</span> my-esm-lib &amp;&amp; <span class="hljs-built_in">cd</span> my-esm-lib<br>$ npm init esm --<span class="hljs-built_in">yes</span><br><span class="hljs-comment"># 使用 -y 或者 --yes 跳过所有提问</span><br></code></pre></td></tr></table></figure><h2 id="npm-install"><a href="#npm-install" class="headerlink" title="npm install"></a>npm install</h2><p><code>npm install</code> 用来安装包所依赖的包，</p><p>默认安装 package.json 里的依赖，如果包内有 packa-lock.json 或者 npm-shrinkwrap.json, yarn.lock 文件，则安装上述文件所指明的依赖。</p><p>使用 <code>-g</code> 或者 <code>--global</code>, 指明安装的包的上下文环境为全局环境。</p><p>设置 <code>--production</code> 标志或者 <code>NODE_ENV</code> 环境变量为 <code>production</code> , npm 将不会安装在 <code>devDependencies</code> 中列出的包。可以设置 <code>--production=false</code> 否掉生产环境，使得npm 安装 <code>dependencies</code> 和 <code>devDependcies</code> 内的包。</p><p><strong><code>-P， --save-prod</code> 包将默认出现在 <code>dependencies</code> 中。</strong></p><p><strong><code>-D，--save-dev</code> 包将出现在 <code>devDependencies</code> 中</strong></p><p><code>-O， --save-optional</code> 包将出现在 <code>optionalDepencies</code> 中</p><p><code>--no-save</code> 包不出现在 <code>dependcies</code> 中</p><h2 id="npx"><a href="#npx" class="headerlink" title="npx"></a>npx</h2><p><code>npm exec -- &lt;pkg&gt;[@&lt;version&gt;] [args...]</code> 运行本地或者远程的包</p>]]></content>
    
    
    
    <tags>
      
      <tag>文档摘抄</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6模块中的export 与import</title>
    <link href="/blog/2021/11/18/ES6%E6%A8%A1%E5%9D%97%E4%B8%AD%E7%9A%84export-%E4%B8%8Eimport/"/>
    <url>/blog/2021/11/18/ES6%E6%A8%A1%E5%9D%97%E4%B8%AD%E7%9A%84export-%E4%B8%8Eimport/</url>
    
    <content type="html"><![CDATA[<p>细说ES6模块中的export 与import。</p><ol><li><p>导出语句必须在模块顶级，不能嵌套在某个块中（import 同理）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 允许</span><br><span class="hljs-keyword">export</span> ... <br><span class="hljs-comment">// 不允许</span><br><span class="hljs-keyword">if</span> (condition) &#123; <br> <span class="hljs-keyword">export</span> ... <br>&#125; <br></code></pre></td></tr></table></figure></li><li><p>命名导出 模块就好像是被导出的值的容器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 允许</span><br><span class="hljs-keyword">const</span> foo = <span class="hljs-string">&#x27;foo&#x27;</span>; <br><span class="hljs-keyword">export</span> &#123; foo &#125;; <br><br><span class="hljs-comment">// 允许</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> foo = <span class="hljs-string">&#x27;foo&#x27;</span>; <br><br><span class="hljs-comment">// 允许，但应该避免</span><br><span class="hljs-keyword">export</span> &#123; foo &#125;; <br><span class="hljs-keyword">const</span> foo = <span class="hljs-string">&#x27;foo&#x27;</span>; <br></code></pre></td></tr></table></figure></li><li><p>别名必须在export 子句的大括号语法中指定（import 同理）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> foo = <span class="hljs-string">&#x27;foo&#x27;</span>; <br><span class="hljs-keyword">export</span> &#123; foo <span class="hljs-keyword">as</span> myFoo &#125;;<br></code></pre></td></tr></table></figure></li><li><p>ES6 模块系统会识别作为别名提供的 default 关键字</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> foo = <span class="hljs-string">&#x27;foo&#x27;</span>; <br><br><span class="hljs-comment">// 等同于 export default foo; </span><br><span class="hljs-keyword">export</span> &#123; foo <span class="hljs-keyword">as</span> <span class="hljs-keyword">default</span> &#125;; <br></code></pre></td></tr></table></figure></li><li><p>正确示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 命名行内导出</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> baz = <span class="hljs-string">&#x27;baz&#x27;</span>; <br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> foo = <span class="hljs-string">&#x27;foo&#x27;</span>, bar = <span class="hljs-string">&#x27;bar&#x27;</span>; <br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;&#125; <br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span>* <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;&#125; <br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123;&#125;  <span class="hljs-comment">// 一边声明就一边导出了</span><br><br><span class="hljs-comment">// 命名子句导出</span><br><span class="hljs-keyword">export</span> &#123; foo &#125;; <br><span class="hljs-keyword">export</span> &#123; foo, bar &#125;; <br><span class="hljs-keyword">export</span> &#123; foo <span class="hljs-keyword">as</span> myFoo, bar &#125;;  <span class="hljs-comment">// 给它加个容器，反正都是要加进来的</span><br><br><span class="hljs-comment">// 默认导出</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;foo&#x27;</span>; <br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-number">123</span>; <br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> /[a-z]*/; <br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123; <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;foo&#x27;</span> &#125;; <br><span class="hljs-keyword">export</span> &#123; foo, bar <span class="hljs-keyword">as</span> <span class="hljs-keyword">default</span> &#125;; <br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> foo <br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125; <br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;&#125; <br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span>*() &#123;&#125; <br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> &#123;&#125;  <span class="hljs-comment">// 记住别名在子句，默认不行内，一个模块一个默认导出</span><br></code></pre></td></tr></table></figure></li><li><p>禁止项</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 会导致错误的不同形式：</span><br><br><span class="hljs-comment">// 行内默认导出中不能出现变量声明</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">const</span> foo = <span class="hljs-string">&#x27;bar&#x27;</span>;  <span class="hljs-comment">// 关键字太多，解释器受不了😫</span><br><br><span class="hljs-comment">// 只有标识符可以出现在 export 子句中</span><br><span class="hljs-keyword">export</span> &#123; <span class="hljs-number">123</span> <span class="hljs-keyword">as</span> foo &#125;<br><br><span class="hljs-comment">// 别名只能在 export 子句中出现</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> foo = <span class="hljs-string">&#x27;foo&#x27;</span> <span class="hljs-keyword">as</span> myFoo; <span class="hljs-comment">// 过于奇怪，解释器不想理你</span><br></code></pre></td></tr></table></figure></li></ol><p>总结一下就是：</p><ul><li>可以在声明时候导出，或者默认导出</li><li>可以把标识符放到括号里，可以在括号也就是子语句里面起别名</li></ul><hr><ol><li><p>与 export 类似，import 必须出现在 模块的顶级</p></li><li><p>命名导出可以使用 <code>*</code> 批量获取并赋值给保存导 出集合的别名，而无须列出每个标识符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> foo = <span class="hljs-string">&#x27;foo&#x27;</span>, bar = <span class="hljs-string">&#x27;bar&#x27;</span>, baz = <span class="hljs-string">&#x27;baz&#x27;</span>; <br><span class="hljs-keyword">export</span> &#123; foo, bar, baz &#125; <br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title class_">Foo</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./foo.js&#x27;</span>;  <span class="hljs-comment">// * 代表整个导出的对象</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Foo</span>.<span class="hljs-property">foo</span>); <span class="hljs-comment">// foo </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Foo</span>.<span class="hljs-property">bar</span>); <span class="hljs-comment">// bar </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Foo</span>.<span class="hljs-property">baz</span>); <span class="hljs-comment">// baz</span><br></code></pre></td></tr></table></figure></li><li><p>如果模块同时导出了命名导出和默认导出，则可以在 import 语句中同时取得它们。可以依次列出 特定导出的标识符来取得，也可以使用*来取得</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> foo, &#123; bar, baz &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./foo.js&#x27;</span>; <br><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> foo, bar, baz &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./foo.js&#x27;</span>; <br><br><span class="hljs-keyword">import</span> foo, * <span class="hljs-keyword">as</span> <span class="hljs-title class_">Foo</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./foo.js&#x27;</span>; <span class="hljs-comment">// 除默认导出外。其它的导出打包到 *</span><br></code></pre></td></tr></table></figure></li></ol><p>总结一下就是：</p><ul><li>默认导出，不加花括号，也就是说不用解构赋值</li><li>在括号中，可以起别名，可以<code>default as xx</code> 正如在导出时 <code>xx as default</code></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>学习总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bigfrontend 代码题(五)</title>
    <link href="/blog/2021/10/23/bigfrontend-%E4%BB%A3%E7%A0%81%E9%A2%98-%E4%BA%94/"/>
    <url>/blog/2021/10/23/bigfrontend-%E4%BB%A3%E7%A0%81%E9%A2%98-%E4%BA%94/</url>
    
    <content type="html"><![CDATA[<h1 id="29-实现async-helper-sequence"><a href="#29-实现async-helper-sequence" class="headerlink" title="29. 实现async helper - sequence()"></a>29. 实现async helper - sequence()</h1><p>该题目和<a href="https://bigfrontend.dev/zh/problem/what-is-composition-create-a-pipe">11. 什么是Composition?实现pipe()</a>有些类似。</p><p>请实现一个async helper - <code>sequence()</code>。<code>sequence()</code>像<code>pipe()</code> 那样将异步函数串联在一起。</p><p>本题目中的所有异步函数是如下interface。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Callback</span> = <span class="hljs-function">(<span class="hljs-params">error: <span class="hljs-built_in">Error</span>, data: <span class="hljs-built_in">any</span></span>) =&gt;</span> <span class="hljs-built_in">void</span><br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">AsyncFunc</span> = <span class="hljs-function">(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">   callback: Callback,</span></span><br><span class="hljs-params"><span class="hljs-function">   data: <span class="hljs-built_in">any</span></span></span><br><span class="hljs-params"><span class="hljs-function"></span>) =&gt;</span> <span class="hljs-built_in">void</span><br></code></pre></td></tr></table></figure><p>你的<code>sequence()</code>需要能接受一个<strong>AsyncFunc 数组</strong>，并且通过callback将之串联在一起。</p><p>假设我们有一个异步函数把数字乘以2</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">asyncTimes2</span> = (<span class="hljs-params">callback, num</span>) =&gt; &#123;<br>   <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">callback</span>(<span class="hljs-literal">null</span>, num * <span class="hljs-number">2</span>), <span class="hljs-number">100</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>sequence()</code> 需要使以下成为可能</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> asyncTimes4 = <span class="hljs-title function_">sequence</span>(<br>  [<br>    asyncTimes2,<br>    asyncTimes2<br>  ]<br>)<br><br><span class="hljs-title function_">asyncTimes4</span>(<span class="hljs-function">(<span class="hljs-params">error, data</span>) =&gt;</span> &#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data) <span class="hljs-comment">// 4</span><br>&#125;, <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>当Error发生的时候，需要直接触发最后的callback，未执行的异步函数需要保持未被调用的状态。</p><p><strong>再问问</strong></p><p>能否使用Promise完成题目？能否不使用Promise完成该题目？</p><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment">type Callback = (error: Error, data: any) =&gt; void</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">type AsyncFunc = (</span><br><span class="hljs-comment">   callback: Callback,</span><br><span class="hljs-comment">   data: any</span><br><span class="hljs-comment">) =&gt; void</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">AsyncFunc[]</span>&#125; <span class="hljs-variable">funcs</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">(callback: Callback) =&gt; void</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sequence</span>(<span class="hljs-params">funcs</span>)&#123;<br>  <span class="hljs-comment">// your code here</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">sequenced</span>(<span class="hljs-params">callback, num</span>) &#123;<br>    <span class="hljs-keyword">if</span>(funcs.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-title function_">callback</span>(<span class="hljs-literal">undefined</span>, num);<br>    <span class="hljs-keyword">const</span> [first, ...rest] = funcs;<br>    <span class="hljs-title function_">first</span>(<span class="hljs-function">(<span class="hljs-params">error, data</span>) =&gt;</span> error ? <span class="hljs-title function_">callback</span>(error) : <span class="hljs-title function_">sequence</span>(rest)(callback, data), num)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="30-实现async-helper-parallel"><a href="#30-实现async-helper-parallel" class="headerlink" title="30. 实现async helper - parallel()"></a>30. 实现async helper - parallel()</h1><p>本题目是 <a href="https://bigfrontend.dev/zh/problem/implement-async-helper-sequence">29. 实现async helper - <code>sequence()</code></a>的延续。</p><p>请实现async helper - <code>parallel()</code>！ <code>parallel()</code> 有点类似<code>Promise.all()</code>。和29题中的 <code>sequence()</code>不同，异步函数的执行没有先后顺序，在<code>parrallel()</code>中是同时触发。</p><p>本题目中的所有异步函数是如下interface。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Callback</span> = <span class="hljs-function">(<span class="hljs-params">error: <span class="hljs-built_in">Error</span>, data: <span class="hljs-built_in">any</span></span>) =&gt;</span> <span class="hljs-built_in">void</span><br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">AsyncFunc</span> = <span class="hljs-function">(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">   callback: Callback,</span></span><br><span class="hljs-params"><span class="hljs-function">   data: <span class="hljs-built_in">any</span></span></span><br><span class="hljs-params"><span class="hljs-function"></span>) =&gt;</span> <span class="hljs-built_in">void</span><br></code></pre></td></tr></table></figure><p>你的<code>parallel()</code> 需要能 <strong>接受 AsyncFunc 数组</strong>，并且返回一个function，这个function将会在所有的异步函数完成或者error发生的时候被触发。</p><p>假设我们有如下3个异步函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">async1</span> = (<span class="hljs-params">callback</span>) =&gt; &#123;<br>   <span class="hljs-title function_">callback</span>(<span class="hljs-literal">undefined</span>, <span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">async2</span> = (<span class="hljs-params">callback</span>) =&gt; &#123;<br>   <span class="hljs-title function_">callback</span>(<span class="hljs-literal">undefined</span>, <span class="hljs-number">2</span>)<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">async3</span> = (<span class="hljs-params">callback</span>) =&gt; &#123;<br>   <span class="hljs-title function_">callback</span>(<span class="hljs-literal">undefined</span>, <span class="hljs-number">3</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>parallel()</code>需要使得以下成为可能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> all = <span class="hljs-title function_">parallel</span>(<br>  [<br>    async1,<br>    async2,<br>    async3<br>  ]<br>)<br><br><span class="hljs-title function_">all</span>(<span class="hljs-function">(<span class="hljs-params">error, data</span>) =&gt;</span> &#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data) <span class="hljs-comment">// [1, 2, 3]</span><br>&#125;, <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>当Error发生的时候，只有第一个error需要被传递到最后，剩下的error和data都被忽略。</p><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment">type Callback = (error: Error, data: any) =&gt; void</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">type AsyncFunc = (</span><br><span class="hljs-comment">   callback: Callback,</span><br><span class="hljs-comment">   data: any</span><br><span class="hljs-comment">) =&gt; void</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">promisify</span> = fn =&gt; <span class="hljs-function"><span class="hljs-params">input</span> =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> &#123;<br>  <span class="hljs-title function_">fn</span>(<span class="hljs-function">(<span class="hljs-params">error, output</span>) =&gt;</span> error ? <span class="hljs-title function_">rej</span>(error) : <span class="hljs-title function_">res</span>(output), input);<br>&#125;);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">AsyncFunc[]</span>&#125; <span class="hljs-variable">funcs</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">(callback: Callback) =&gt; void</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">parallel</span>(<span class="hljs-params">funcs</span>)&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">cb, input</span>) =&gt;</span> &#123;<br>    <span class="hljs-title class_">Promise</span><br>    .<span class="hljs-title function_">all</span>(funcs.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> <span class="hljs-title function_">promisify</span>(fn)(input)))<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">output</span> =&gt;</span> <span class="hljs-title function_">cb</span>(<span class="hljs-literal">undefined</span>, output))<br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-title function_">cb</span>(error, <span class="hljs-literal">undefined</span>))<br>  &#125;<br>&#125;<br><br><br><span class="hljs-comment">// Promise 对象是由关键字 new 及其构造函数来创建的。</span><br><span class="hljs-comment">// 该构造函数会把一个叫做“处理器函数”（executor function）的函数作为它的参数。</span><br><span class="hljs-comment">// 这个“处理器函数”接受两个函数——resolve 和 reject ——作为其参数。当异步任务顺利完成且返回结果值时，会调用 resolve 函数；</span><br><span class="hljs-comment">// 而当异步任务失败且返回失败原因（通常是一个错误对象）时，会调用reject 函数。</span><br><br><br><span class="hljs-comment">// 有不明白的地方，在fn 利用input 执行完异步操作后，output 和error 是如何传到外面的？</span><br></code></pre></td></tr></table></figure><hr><h1 id="31-实现async-helper-race"><a href="#31-实现async-helper-race" class="headerlink" title="31. 实现async helper - race()"></a>31. 实现async helper - race()</h1><p>这个题目是<a href="https://bigfrontend.dev/zh/problem/implement-async-helper-parallel">30. 实现async helper - <code>parallel()</code></a>的后续。</p><p>请实现一个async function helper - <code>race()</code> 。 <code>race()</code>有点类似<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race">Promise.race()</a>。 <code>parallel()</code>会等待所有的function执行结束，<code>race()</code>会在任何一个function结束或者产生error的时候调用最终的callback。</p><p>本题目中的所有异步函数是如下interface。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Callback</span> = <span class="hljs-function">(<span class="hljs-params">error: <span class="hljs-built_in">Error</span>, data: <span class="hljs-built_in">any</span></span>) =&gt;</span> <span class="hljs-built_in">void</span><br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">AsyncFunc</span> = <span class="hljs-function">(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">   callback: Callback,</span></span><br><span class="hljs-params"><span class="hljs-function">   data: <span class="hljs-built_in">any</span></span></span><br><span class="hljs-params"><span class="hljs-function"></span>) =&gt;</span> <span class="hljs-built_in">void</span><br></code></pre></td></tr></table></figure><p>你的<code>race()</code> 需要 <strong>接受 AsyncFunc 数组</strong>，并且返回一个新的函数。这个函数会在任何一个function调用结束或者发生error的时候被调用。</p><p>假设我们有如下3个async function。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">async1</span> = (<span class="hljs-params">callback</span>) =&gt; &#123;<br>   <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">callback</span>(<span class="hljs-literal">undefined</span>, <span class="hljs-number">1</span>), <span class="hljs-number">300</span>)<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">async2</span> = (<span class="hljs-params">callback</span>) =&gt; &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">callback</span>(<span class="hljs-literal">undefined</span>, <span class="hljs-number">2</span>), <span class="hljs-number">100</span>)<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">async3</span> = (<span class="hljs-params">callback</span>) =&gt; &#123;<br>   <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">callback</span>(<span class="hljs-literal">undefined</span>, <span class="hljs-number">3</span>), <span class="hljs-number">200</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>你的<code>race()</code> 需要使得如下逻辑成立。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> first = <span class="hljs-title function_">race</span>(<br>  [<br>    async1,<br>    async2,<br>    async3<br>  ]<br>)<br><br><span class="hljs-title function_">first</span>(<span class="hljs-function">(<span class="hljs-params">error, data</span>) =&gt;</span> &#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data) <br>   <span class="hljs-comment">// 2, 因为2是第一个成功执行的结果</span><br>&#125;, <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment">type Callback = (error: Error, data: any) =&gt; void</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">type AsyncFunc = (</span><br><span class="hljs-comment">   callback: Callback,</span><br><span class="hljs-comment">   data: any</span><br><span class="hljs-comment">) =&gt; void</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">AsyncFunc[]</span>&#125; <span class="hljs-variable">funcs</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">(callback: Callback) =&gt; void</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">race</span>(<span class="hljs-params">funcs</span>)&#123;<br>  <span class="hljs-comment">// your code here</span><br>  <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">cb, data</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">cbWrapper</span> = (<span class="hljs-params">...args</span>) =&gt; &#123;<br>      <span class="hljs-keyword">if</span>(flag) <span class="hljs-keyword">return</span>;<br>      <span class="hljs-title function_">cb</span>(...args);<br>      flag = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    funcs.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">func</span> =&gt;</span> <span class="hljs-title function_">func</span>(cbWrapper, data));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="32-实现Promise-all"><a href="#32-实现Promise-all" class="headerlink" title="32. 实现Promise.all()"></a>32. 实现Promise.all()</h1><blockquote><p>Promise.all(iterable) 方法返回一个 Promise 实例，此实例在 iterable 参数内所有的 promise 都“完成（resolved）”或参数中不包含 promise 时回调完成（resolve）；如果参数中 promise 有一个失败（rejected），此实例回调失败（reject），失败的原因是第一个失败 promise 的结果。</p></blockquote><p>source - <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/all">MDN</a></p><p>你能否实现自己的 <code>Promise.all()</code> ?</p><p><em>注意</em></p><p><strong>请不要直接使用Promise.all()</strong> ，这并不能帮助你提升。</p><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Array&lt;any&gt;</span>&#125; <span class="hljs-variable">promises</span> - notice input might have non-Promises</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">Promise&lt;any[]&gt;</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">all</span>(<span class="hljs-params">promises</span>) &#123;<br>  <span class="hljs-comment">// your code here</span><br>  <span class="hljs-keyword">let</span> result = [];<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> promise <span class="hljs-keyword">of</span> promises) &#123;<br>    result.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">await</span> promise);<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// 可以看出，用async 和await 更符合直觉</span><br><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">all</span>(<span class="hljs-params">promises</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> result = [];<br><br>    <span class="hljs-keyword">if</span>(promises.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-title function_">res</span>(result);<br><br>    <span class="hljs-keyword">let</span> countPending = promises.<span class="hljs-property">length</span>;<br>    promises.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">promise, index</span>) =&gt;</span> &#123;<br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(promise).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>        result[index] = value;<br>        countPending--;<br>        <span class="hljs-keyword">if</span>(countPending === <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-title function_">res</span>(result);<br>        &#125;<br>      &#125;, rej)<br>    &#125;)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="33-实现Promise-allSettled"><a href="#33-实现Promise-allSettled" class="headerlink" title="33. 实现Promise.allSettled()"></a>33. 实现Promise.allSettled()</h1><blockquote><p>Promise.allSettled()方法返回一个在所有给定的promise都已经fulfilled或rejected后的promise，并带有一个对象数组，每个对象表示对应的promise结果。</p></blockquote><ul><li>from <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled">MDN</a></li></ul><p>和<code>Promise.all()</code>不同，<code>Promise.allSettled()</code> 会等待所有的promise直到fulfill或者reject。</p><p>你能实现自己的<code>Promise.allSettled()</code> 吗?</p><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Array&lt;any&gt;</span>&#125; <span class="hljs-variable">promises</span> - notice that input might contains non-promises</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">Promise&lt;Array&lt;&#123;status: &#x27;fulfilled&#x27;, value: any</span>&#125; | &#123;status: &#x27;rejected&#x27;, reason: any&#125;&gt;&gt;&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">allSettled</span>(<span class="hljs-params">promises</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(promises.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">promise</span> =&gt;</span> <br>  <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(promise).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;fulfilled&quot;</span>,<br>      value<br>    &#125;<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;rejected&quot;</span>,<br>      reason<br>    &#125;<br>  &#125;)<br>  ))<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="34-实现Promise-any"><a href="#34-实现Promise-any" class="headerlink" title="34. 实现Promise.any()"></a>34. 实现Promise.any()</h1><blockquote><p>Promise.any() 接收一个Promise可迭代对象，只要其中的一个 promise 成功，就返回那个已经成功的 promise 。如果可迭代对象中没有一个 promise 成功（即所有的 promises 都失败/拒绝），就返回一个失败的 promise 和AggregateError类型的实例，它是 Error 的一个子类，用于把单一的错误集合在一起。本质上，这个方法和Promise.all()是相反的。</p></blockquote><ul><li>from <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/any">MDN</a></li></ul><p>你能实现自己的<code>Promise.any()</code>吗?</p><p><em>注意</em></p><p><code>AggregateError</code> 暂时还没有被Chrome支持。但是你仍然可以使用它因为我们在judge你的code时候添加了AggregateError。</p><p>你可以这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">AggregateError</span>(<br>  <span class="hljs-string">&#x27;No Promise in Promise.any was resolved&#x27;</span>, <br>  errors<br>)<br></code></pre></td></tr></table></figure><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Array&lt;Promise&gt;</span>&#125; <span class="hljs-variable">promises</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">Promise</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">any</span>(<span class="hljs-params">promises</span>) &#123;<br>  <span class="hljs-comment">// your code here</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> isFullfilled = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">let</span> errors = [];<br>    promises.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">promise, index</span>) =&gt;</span> &#123;<br>      promise.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span>(!isFullfilled) &#123;<br>          <span class="hljs-title function_">res</span>(data);<br>          isFullfilled = <span class="hljs-literal">true</span>;<br>        &#125;<br>      &#125;, <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>        errors[index] = error;<br>        <span class="hljs-keyword">if</span>(errors.<span class="hljs-property">length</span> === promises.<span class="hljs-property">length</span>) &#123;<br>          <span class="hljs-title function_">rej</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AggregateError</span>(<span class="hljs-string">&#x27;none resolved&#x27;</span>, errors));<br>        &#125;<br>      &#125;)<br>    &#125;)<br>  &#125;)<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h1 id="35-实现Promise-race"><a href="#35-实现Promise-race" class="headerlink" title="35. 实现Promise.race()"></a>35. 实现Promise.race()</h1><p>该问题有些类似 <a href="https://bigfrontend.dev/zh/problem/implement-async-helper-race">31. 实现async helper - <code>race()</code></a>，只不过处理的是Promise。</p><blockquote><p>Promise.race(iterable) 方法返回一个 promise，一旦迭代器中的某个promise解决或拒绝，返回的 promise就会解决或拒绝。source: <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/race">MDN</a></p></blockquote><p>你能实现自己的<code>Promise.race()</code>吗？</p><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Array&lt;Promise&gt;</span>&#125; <span class="hljs-variable">promises</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">Promise</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">race</span>(<span class="hljs-params">promises</span>) &#123;<br>  <span class="hljs-comment">// your code here</span><br>  <span class="hljs-keyword">return</span> !promises.<span class="hljs-property">length</span> ? <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> promise <span class="hljs-keyword">of</span> promises) &#123;<br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(promise).<span class="hljs-title function_">then</span>(res, rej);<br>      <span class="hljs-comment">// promise.then(res, rej);</span><br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="36-实现一个-fake-timer-setTimeout"><a href="#36-实现一个-fake-timer-setTimeout" class="headerlink" title="36. 实现一个 fake timer(setTimeout)"></a>36. 实现一个 fake timer(setTimeout)</h1><p><code>setTimeout</code> 可以设定未来的任务，但是其执行时间并不精确。(<a href="https://javascript.info/event-loop">Event Loop</a>)。</p><p>大多数时候这都不是问题，但是在test的时候却有些头疼。</p><p>比如，<a href="https://bigfrontend.dev/zh/problem/implement-throttle-with-leading-and-trailing-option">5. 手写throttle()并支持leading 和 trailing</a> 中我们就需要比较精确的测试。</p><p>你能否实现一个静态化的<code>setTimeout()</code>和<code>clearTimeout()</code>，而不再有Event Loop的问题。这也正是<a href="https://github.com/sinonjs/fake-timers">FakeTimes</a> 的用途。</p><p>“精确”的意思是，“假设所有的函数的执行耗时为0，同时时间戳从0开始，那么<code>setTimeout(func1, 100)</code>将会精确的在时间戳:100进行执行func1”。</p><p>你需要同时修改<code>Date.now()</code>来提供新的时间戳。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FakeTimer</span> &#123;<br>  <span class="hljs-title function_">install</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// setTimeout(), clearTimeout(), and Date.now() </span><br>    <span class="hljs-comment">// are replaced</span><br>  &#125;<br><br>  <span class="hljs-title function_">uninstall</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// restore the original APIs</span><br>    <span class="hljs-comment">// setTimeout(), clearTimeout() and Date.now()</span><br>  &#125;<br><br>  <span class="hljs-title function_">tick</span>(<span class="hljs-params"></span>) &#123;<br>     <span class="hljs-comment">// run all the schedule functions in order</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输入的代码将会大概像这样进行测试。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fakeTimer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FakeTimer</span>()<br>fakeTimer.<span class="hljs-title function_">install</span>()<br><br><span class="hljs-keyword">const</span> logs = []<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">log</span> = (<span class="hljs-params">arg</span>) =&gt; &#123;<br>   logs.<span class="hljs-title function_">push</span>([<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>(), arg])<br>&#125;<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;A&#x27;</span>), <span class="hljs-number">100</span>)<br><span class="hljs-comment">// log &#x27;A&#x27; at 100</span><br><br><span class="hljs-keyword">const</span> b = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;B&#x27;</span>), <span class="hljs-number">110</span>)<br><span class="hljs-built_in">clearTimeout</span>(b)<br><span class="hljs-comment">// b is set but cleared</span><br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;C&#x27;</span>), <span class="hljs-number">200</span>)<br><br><span class="hljs-title function_">expect</span>(logs).<span class="hljs-title function_">toEqual</span>([[<span class="hljs-number">100</span>, <span class="hljs-string">&#x27;A&#x27;</span>], [<span class="hljs-number">200</span>, <span class="hljs-string">&#x27;C&#x27;</span>]])<br><br>fakeTimer.<span class="hljs-title function_">uninstall</span>()<br></code></pre></td></tr></table></figure><p><em>注意</em></p><p>测试的时候只会用到<code>Date.now()</code>，其他的时间相关的函数可以忽略。</p><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FakeTimer</span> &#123;<br><span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">original</span> = &#123;<br>    <span class="hljs-attr">setTimeout</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">setTimeout</span>,<br>    <span class="hljs-attr">clearTimeout</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">clearTimeout</span>,<br>    <span class="hljs-attr">dateNow</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-property">now</span><br>  &#125;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentTime</span> = <span class="hljs-number">0</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span> = [];<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">timerId</span> = <span class="hljs-number">1</span>;<br>&#125;<br><br>  <span class="hljs-title function_">install</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// replace window.setTimeout, window.clearTimeout, Date.now</span><br>    <span class="hljs-comment">// with your implementation</span><br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">setTimeout</span> = <span class="hljs-function">(<span class="hljs-params">cb, time, ...args</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">let</span> id = <span class="hljs-variable language_">this</span>.<span class="hljs-property">timerId</span>++;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span>.<span class="hljs-title function_">push</span>(&#123;<br>        cb,<br>        <span class="hljs-attr">time</span>: time+<span class="hljs-variable language_">this</span>.<span class="hljs-property">currentTime</span>,<br>        id,<br>        args<br>      &#125;)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span>.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a,b</span>) =&gt;</span> a.<span class="hljs-property">time</span> - b.<span class="hljs-property">time</span>);<br>    <span class="hljs-keyword">return</span> id;      <br>    &#125;<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">clearTimeout</span> = <span class="hljs-function"><span class="hljs-params">toRemoveId</span> =&gt;</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">obj</span> =&gt;</span> obj.<span class="hljs-property">id</span> !== toRemoveId);<br>    &#125;<br>    <span class="hljs-title class_">Date</span>.<span class="hljs-property">now</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentTime</span>;<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-title function_">uninstall</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// restore the original implementation of</span><br>    <span class="hljs-comment">// window.setTimeout, window.clearTimeout, Date.now</span><br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">setTimeout</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">original</span>.<span class="hljs-property">setTimeout</span>;<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">clearTimeout</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">original</span>.<span class="hljs-property">clearTimeout</span>;<br>    <span class="hljs-title class_">Date</span>.<span class="hljs-property">now</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">original</span>.<span class="hljs-property">dateNow</span>;<br>  &#125;<br>  <br>  <span class="hljs-title function_">tick</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// run the scheduled functions without waiting</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span>.<span class="hljs-property">length</span>) &#123;<br>      <span class="hljs-keyword">let</span> &#123; cb, time, args&#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span>.<span class="hljs-title function_">shift</span>();<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentTime</span> = time;<br>      <span class="hljs-title function_">cb</span>(...args);<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 本质上是构造一个类，去替换掉原生的计时器方法</span><br></code></pre></td></tr></table></figure><hr><h1 id="37-手写Binary-Search-unique"><a href="#37-手写Binary-Search-unique" class="headerlink" title="37. 手写Binary Search (unique)"></a>37. 手写Binary Search (unique)</h1><p>即使是前端的面试，基本的算法比如<a href="https://en.wikipedia.org/wiki/Binary_search_algorithm">二分查找</a>被问到的可能性还是有的。</p><p><strong>请实现一个二分查找，对象是不重复，升序整数数组</strong>。</p><p>请不要直接使用<code>Array.prototype.indexOf()</code>，这不是本题的目的。</p><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">arr</span> - ascending unique array</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">target</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">binarySearch</span>(<span class="hljs-params">arr, target</span>)&#123;<br>  <span class="hljs-comment">// your code here</span><br>  <span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span>, end = arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span>(start &lt;= end) &#123;<br>    <span class="hljs-keyword">let</span> mid = <span class="hljs-built_in">parseInt</span>((start+end) / <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span>(target === arr[mid]) &#123;<br>      <span class="hljs-keyword">return</span> mid;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target &lt; arr[mid]) &#123;<br>      end = mid - <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      start = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="38-实现jest-spyOn"><a href="#38-实现jest-spyOn" class="headerlink" title="38. 实现jest.spyOn()"></a>38. 实现jest.spyOn()</h1><p>如果你写过单元测试的话，一定很熟悉<code>Spy</code>的用法。</p><p><strong>请自己实现一个spyOn(object, methodName)</strong> ，类似于 <a href="https://jestjs.io/docs/en/jest-object#jestspyonobject-methodname">jest.spyOn()</a>。</p><p>以下是<code>spyOn</code>需要完成的内容。</p><ol><li>spy被调用的时候，原来的method也需要被调用。</li><li>spy需要又一个<code>calls</code>数组，数组中含有所有调用的参数</li></ol><p>以下代码说明了一切。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> obj = &#123;<br>   <span class="hljs-attr">data</span>: <span class="hljs-number">1</span>, <br>   <span class="hljs-title function_">increment</span>(<span class="hljs-params">num</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> += num<br>   &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> spy = <span class="hljs-title function_">spyOn</span>(obj, <span class="hljs-string">&#x27;increment&#x27;</span>)<br><br>obj.<span class="hljs-title function_">increment</span>(<span class="hljs-number">1</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">data</span>) <span class="hljs-comment">// 2</span><br><br>obj.<span class="hljs-title function_">increment</span>(<span class="hljs-number">2</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">data</span>) <span class="hljs-comment">// 4</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(spy.<span class="hljs-property">calls</span>)<br><span class="hljs-comment">// [ [1], [2] ]</span><br></code></pre></td></tr></table></figure><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">object</span>&#125; <span class="hljs-variable">obj</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">methodName</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">spyOn</span>(<span class="hljs-params">obj, methodName</span>) &#123;<br>  <span class="hljs-comment">// your code here</span><br>  <span class="hljs-keyword">const</span> method = obj[methodName];<br>  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> method !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;methodName&#125;</span> is not a function`</span>);<br>  &#125;<br>  <span class="hljs-keyword">const</span> calls = [];<br>  obj[methodName] = <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> &#123;<br>    calls.<span class="hljs-title function_">push</span>(args);<br>    method.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args)<br>  &#125;<br>  <span class="hljs-keyword">return</span> &#123; calls &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="39-手写range"><a href="#39-手写range" class="headerlink" title="39. 手写range()"></a>39. 手写range()</h1><p>请实现一个<code>range(from, to)</code> 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> num <span class="hljs-keyword">of</span> <span class="hljs-title function_">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>)) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num)  <br>&#125;<br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 3</span><br><span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure><p>这个题目非常简单，注意你不一定必须要返回一个数组，你能想到除了for循环之外更多更炫酷的解法吗？</p><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">integer</span>&#125; <span class="hljs-variable">from</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">integer</span>&#125; <span class="hljs-variable">to</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">range</span>(<span class="hljs-params"><span class="hljs-keyword">from</span>, to</span>) &#123;<br>  <span class="hljs-comment">// your code here</span><br>  <span class="hljs-keyword">let</span> result = [];<br>  <span class="hljs-keyword">while</span>(<span class="hljs-keyword">from</span> &lt;= to) &#123;<br>    result.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">from</span>++);<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// 2. implement iterable/iterator protocol</span><br><span class="hljs-comment">// for ... of uses interable protocol</span><br><span class="hljs-comment">// [Symbol.iterator]: () =&gt;  Iterator</span><br><span class="hljs-comment">// next: () =&gt; &#123;done: bolean, value?: any&#125; </span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">range</span>(<span class="hljs-params"><span class="hljs-keyword">from</span>, to</span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-comment">// iterable protocol</span><br>    [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() &#123;<br>      <span class="hljs-comment">// iterator protocol</span><br>      <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) &#123;<br>          <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">done</span>: <span class="hljs-keyword">from</span> &gt; to,<br>            <span class="hljs-attr">value</span>: <span class="hljs-keyword">from</span>++<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="40-实现Bubble-Sort"><a href="#40-实现Bubble-Sort" class="headerlink" title="40. 实现Bubble Sort"></a>40. 实现Bubble Sort</h1><p>即使是前端开发，也需要掌握基本的排序算法。</p><p>请手写<a href="https://en.wikipedia.org/wiki/Bubble_sort">Bubble Sort</a>。</p><p>请直接修改传入的数组，不要返回新数组。</p><p><em>追问</em></p><p>时间空间复杂度是多少？是否是稳定的排序？</p><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">arr</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bubbleSort</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-comment">// your code here</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>; i++) &#123; <span class="hljs-comment">// 要遍历的次数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; arr.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>-i; j++) &#123; <span class="hljs-comment">// 具体遍历的索引</span><br>      <span class="hljs-keyword">if</span>(arr[j] &gt; arr[j+<span class="hljs-number">1</span>]) &#123;<br>        [arr[j] ,arr[j+<span class="hljs-number">1</span>]] = [arr[j+<span class="hljs-number">1</span>], arr[j]];<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br><br><span class="hljs-comment">// 维基百科的示例代码</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">bubble_sort</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">var</span> i, j, temp;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i++)<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span> - i; j++)<br><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>[j] &gt; <span class="hljs-variable language_">this</span>[j + <span class="hljs-number">1</span>]) &#123;<br>temp = <span class="hljs-variable language_">this</span>[j];<br><span class="hljs-variable language_">this</span>[j] = <span class="hljs-variable language_">this</span>[j + <span class="hljs-number">1</span>];<br><span class="hljs-variable language_">this</span>[j + <span class="hljs-number">1</span>] = temp;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>&#125;;<br><span class="hljs-keyword">var</span> num = [<span class="hljs-number">22</span>, <span class="hljs-number">34</span>, <span class="hljs-number">3</span>, <span class="hljs-number">32</span>, <span class="hljs-number">82</span>, <span class="hljs-number">55</span>, <span class="hljs-number">89</span>, <span class="hljs-number">50</span>, <span class="hljs-number">37</span>, <span class="hljs-number">5</span>, <span class="hljs-number">64</span>, <span class="hljs-number">35</span>, <span class="hljs-number">9</span>, <span class="hljs-number">70</span>];<br>num.<span class="hljs-title function_">bubble_sort</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; num.<span class="hljs-property">length</span>; i++)<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">innerHTML</span> += num[i] + <span class="hljs-string">&quot; &quot;</span>;<br></code></pre></td></tr></table></figure><hr><h1 id="41-手写Merge-Sort"><a href="#41-手写Merge-Sort" class="headerlink" title="41. 手写Merge Sort"></a>41. 手写Merge Sort</h1><p>即使是前端开发，也需要掌握基本的排序算法。</p><p>请手写<a href="https://en.wikipedia.org/wiki/Merge_sort">Merge Sort</a>。</p><p>请直接修改传入的数组，不要返回新数组。</p><p><em>追问</em></p><p>时间空间复杂度是多少？是否是稳定的排序？</p><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 维基百科版本</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">left, right</span>)&#123;<br>  <span class="hljs-keyword">var</span> result = [];<br>  <span class="hljs-keyword">while</span>(left.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span> &amp;&amp; right.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">if</span>(left[<span class="hljs-number">0</span>] &lt; right[<span class="hljs-number">0</span>])&#123;<br>      result.<span class="hljs-title function_">push</span>(left.<span class="hljs-title function_">shift</span>());<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      result.<span class="hljs-title function_">push</span>(right.<span class="hljs-title function_">shift</span>());<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result.<span class="hljs-title function_">concat</span>(left, right);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mergeSort</span>(<span class="hljs-params">arr</span>)&#123;<br>  <span class="hljs-keyword">if</span>(arr.<span class="hljs-property">length</span> &lt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> arr;<br>  <span class="hljs-keyword">var</span> middle = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(arr.<span class="hljs-property">length</span> / <span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">var</span> left = arr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, middle);<br>  <span class="hljs-keyword">var</span> right = arr.<span class="hljs-title function_">slice</span>(middle);<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">merge</span>(<span class="hljs-title function_">mergeSort</span>(left), <span class="hljs-title function_">mergeSort</span>(right));<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">arr</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mergeSort</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">if</span> (arr.<span class="hljs-property">length</span> &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span><br><br>  <span class="hljs-keyword">let</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(arr.<span class="hljs-property">length</span> / <span class="hljs-number">2</span>)<br>  <span class="hljs-keyword">let</span> left = arr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, mid)<br>  <span class="hljs-keyword">let</span> right = arr.<span class="hljs-title function_">slice</span>(mid)<br>  <br>  <span class="hljs-title function_">mergeSort</span>(left)<br>  <span class="hljs-title function_">mergeSort</span>(right)<br>  <br>  <span class="hljs-keyword">let</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">while</span> (l &lt; left.<span class="hljs-property">length</span> || r &lt; right.<span class="hljs-property">length</span>)<br>    arr[l+r] = (r === right.<span class="hljs-property">length</span> || left[l] &lt;= right[r]) ? left[l++] : right[r++] <span class="hljs-comment">// ⭐⭐</span><br>&#125;<br><span class="hljs-comment">// 很巧妙啊，双指针的写法</span><br><span class="hljs-comment">// r===right.length 是为了让右数组用完后,可以继续进行左数组的赋值.</span><br><span class="hljs-comment">// 如果是左数组用完,判断式子自然为false, 执行右数组的赋值</span><br></code></pre></td></tr></table></figure><hr><h1 id="42-手写-Insertion-Sort"><a href="#42-手写-Insertion-Sort" class="headerlink" title="42. 手写 Insertion Sort"></a>42. 手写 Insertion Sort</h1><p>即使是前端开发，也需要掌握基本的排序算法。</p><p>请手写<a href="https://en.wikipedia.org/wiki/Insertion_sort">Insertion Sort</a>。</p><p>请直接修改传入的数组，不要返回新数组。</p><p><em>追问</em></p><p>时间空间复杂度是多少？是否是稳定的排序？</p><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">arr</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">insertionSort</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-comment">// your code here</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span>; i&lt;arr.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">let</span> key = arr[i];<br>    <span class="hljs-keyword">let</span> j = i - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; key) &#123;<br>      arr[j+<span class="hljs-number">1</span>] = arr[j];<br>      j--;<br>    &#125;<br>    arr[j+<span class="hljs-number">1</span>] = key;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 插入排序的核心在于, 一个一个比较,腾笼换鸟</span><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    
    <tags>
      
      <tag>做题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bigfrontend 代码题(四)</title>
    <link href="/blog/2021/10/21/bigfrontend-%E4%BB%A3%E7%A0%81%E9%A2%98-%E5%9B%9B/"/>
    <url>/blog/2021/10/21/bigfrontend-%E4%BB%A3%E7%A0%81%E9%A2%98-%E5%9B%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="16-实现一个Event-Emitter"><a href="#16-实现一个Event-Emitter" class="headerlink" title="16. 实现一个Event Emitter"></a>16. 实现一个Event Emitter</h1><p>Node.js中有<a href="https://nodejs.org/api/events.html#events_class_eventemitter">Event Emitter</a>，Facebook 也曾经有<a href="https://github.com/facebookarchive/emitter">自己的实现</a> 不过已经archive了。</p><p>请实现你自己的 Event Emitter</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> emitter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Emitter</span>()<br></code></pre></td></tr></table></figure><p>它需要支持事件订阅</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> sub1  = emitter.<span class="hljs-title function_">subscribe</span>(<span class="hljs-string">&#x27;event1&#x27;</span>, callback1)<br><span class="hljs-keyword">const</span> sub2 = emitter.<span class="hljs-title function_">subscribe</span>(<span class="hljs-string">&#x27;event2&#x27;</span>, callback2)<br><br><span class="hljs-comment">// 同一个callback可以重复订阅同一个事件</span><br><span class="hljs-keyword">const</span> sub3 = emitter.<span class="hljs-title function_">subscribe</span>(<span class="hljs-string">&#x27;event1&#x27;</span>, callback1)<br></code></pre></td></tr></table></figure><p><code>emit(eventName, ...args)</code> 可以用来触发callback</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">emitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;event1&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><span class="hljs-comment">// callback1 会被调用两次</span><br></code></pre></td></tr></table></figure><p><code>subscribe()</code>返回一个含有<code>release()</code>的对象，可以用来取消订阅。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">sub1.<span class="hljs-title function_">release</span>()<br>sub3.<span class="hljs-title function_">release</span>()<br><span class="hljs-comment">// 现在即使&#x27;event1&#x27;被触发, </span><br><span class="hljs-comment">// callback1 也不会被调用</span><br></code></pre></td></tr></table></figure><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// please complete the implementation</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventEmitter</span> &#123;<br>  eventCache = &#123;&#125;; cbId = <span class="hljs-number">0</span>;<br>  <span class="hljs-title function_">subscribe</span>(<span class="hljs-params">eventName, callback</span>) &#123;<br>  <span class="hljs-keyword">const</span> eventKey = eventName, funcId = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cbId</span>++;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventCache</span>[eventKey] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventCache</span>[eventKey] || &#123;&#125;;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventCache</span>[eventKey][funcId] = callback;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">release</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventCache</span>[eventKey][funcId];<br>      &#125;<br>    &#125;<br><br>  &#125;<br>  <br>  <span class="hljs-title function_">emit</span>(<span class="hljs-params">eventName, ...args</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventCache</span>[eventName] &amp;&amp; <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">eventCache</span>[eventName]).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">cb</span> =&gt;</span> cb.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, args))<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// Emitter 实际上就是一个存储回调的特殊对象</span><br></code></pre></td></tr></table></figure><hr><h1 id="17-实现一个DOM-element-store"><a href="#17-实现一个DOM-element-store" class="headerlink" title="17. 实现一个DOM element store"></a>17. 实现一个DOM element store</h1><p>JavaScript中有<code>Map</code>，我们可以用任何data做key，即便是DOM元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br>map.<span class="hljs-title function_">set</span>(domNode, somedata)<br></code></pre></td></tr></table></figure><p>如果运行的JavaScript不支持Map，我们如何能让上述代码能够工作？</p><p>请在不利用Map的条件下实现一个Node Store，支持DOM element作为key。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NodeStore</span> &#123;<br><br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">node, value</span>) &#123;<br><br>  &#125;<br>  <br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">node</span>) &#123;<br><br>  &#125;<br>  <br>  <span class="hljs-title function_">has</span>(<span class="hljs-params">node</span>) &#123;<br><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>你可以实现一个通用的Map polyfill。或者利用以下DOM元素的特性来做文章？</p><p>请注意时间空间复杂度。</p><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NodeStore</span> &#123;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">store</span> = &#123;&#125;;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">nodeKey</span> = <span class="hljs-title class_">Symbol</span>();<br>  &#125;<br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Node</span>&#125; <span class="hljs-variable">node</span></span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">any</span>&#125; <span class="hljs-variable">value</span></span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">node, value</span>) &#123;<br>    node[<span class="hljs-variable language_">this</span>.<span class="hljs-property">nodeKey</span>] = <span class="hljs-title class_">Symbol</span>();<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">store</span>[node[<span class="hljs-variable language_">this</span>.<span class="hljs-property">nodeKey</span>]] = value;<br>  &#125;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Node</span>&#125; <span class="hljs-variable">node</span></span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">any</span>&#125;</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">node</span>) &#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">store</span>[node[<span class="hljs-variable language_">this</span>.<span class="hljs-property">nodeKey</span>]];<br>  &#125;<br>  <br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Node</span>&#125; <span class="hljs-variable">node</span></span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">Boolean</span>&#125;</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title function_">has</span>(<span class="hljs-params">node</span>) &#123;<br>    <span class="hljs-keyword">return</span> !!<span class="hljs-variable language_">this</span>.<span class="hljs-property">store</span>[node[<span class="hljs-variable language_">this</span>.<span class="hljs-property">nodeKey</span>]];<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 基本思路就是给node 加一个属性，设置一个独一无二的值Symbol()，然后存起来</span><br></code></pre></td></tr></table></figure><hr><h1 id="18-优化一个function"><a href="#18-优化一个function" class="headerlink" title="18. 优化一个function"></a>18. 优化一个function</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// items是一个array</span><br><span class="hljs-comment">// 包含的元素有 &gt;=3 个属性</span><br><br><span class="hljs-keyword">let</span> items = [<br>  &#123;<span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;tv&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>&#125;, <br>  &#123;<span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;silver&#x27;</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;phone&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>&#125;,<br>  &#123;<span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;book&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">17</span>&#125;<br>] <br><br><span class="hljs-comment">// 一个由key和value组成的array</span><br><span class="hljs-keyword">const</span> excludes = [ <br>  &#123;<span class="hljs-attr">k</span>: <span class="hljs-string">&#x27;color&#x27;</span>, <span class="hljs-attr">v</span>: <span class="hljs-string">&#x27;silver&#x27;</span>&#125;, <br>  &#123;<span class="hljs-attr">k</span>: <span class="hljs-string">&#x27;type&#x27;</span>, <span class="hljs-attr">v</span>: <span class="hljs-string">&#x27;tv&#x27;</span>&#125;, <br>  ...<br>] <br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">excludeItems</span>(<span class="hljs-params">items, excludes</span>) &#123; <br>  excludes.<span class="hljs-title function_">forEach</span>( <span class="hljs-function"><span class="hljs-params">pair</span> =&gt;</span> &#123; <br>    items = items.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item[pair.<span class="hljs-property">k</span>] === item[pair.<span class="hljs-property">v</span>])<br>  &#125;)<br> <br>  <span class="hljs-keyword">return</span> items<br>&#125; <br></code></pre></td></tr></table></figure><ol><li>上述<code>excludeItems</code>方法是什么用途?</li><li>上述方法是否和设想的一样在运作?</li><li>上述方法的时间复杂度是?</li><li>你能否优化以下?</li></ol><p><em>注意</em></p><p>BFE.dev仅仅根据结果进行judge，不会考虑时间成本。请提交你觉得最好的解答。</p><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">object[]</span>&#125; <span class="hljs-variable">items</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@excludes</span> &#123;<span class="hljs-type"> Array&lt; &#123;k: string, v: any</span>&#125; &gt;&#125; excludes</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">object[]</span>&#125; <span class="hljs-variable">items</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type"> Array&lt; &#123;k: string, v: any</span>&#125; &gt;&#125; excludes</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">object[]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">excludeItems</span>(<span class="hljs-params">items, excludes</span>) &#123;<br>  items = items.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> pair <span class="hljs-keyword">of</span> excludes) &#123;<br>      <span class="hljs-keyword">if</span>(item[pair.<span class="hljs-property">k</span>] === pair.<span class="hljs-property">v</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;)<br>  <span class="hljs-keyword">return</span> items;<br>&#125;<br><br><span class="hljs-comment">// 不难，搞清楚filter 返回的数组以及对象的属性取值即可</span><br></code></pre></td></tr></table></figure><hr><h1 id="19-相同结构的DOM-tree上面寻找对应的节点"><a href="#19-相同结构的DOM-tree上面寻找对应的节点" class="headerlink" title="19. 相同结构的DOM tree上面寻找对应的节点"></a>19. 相同结构的DOM tree上面寻找对应的节点</h1><p>给定两个完全一样的DOM Tree <strong>A</strong>和<strong>B</strong>，以及<strong>A</strong>中的元素<strong>a</strong>，请找到<strong>B</strong>中对应的元素<strong>b</strong>。</p><p><strong>补充说明</strong></p><p>这个问题可以出在一般的树结构上，DOM Tree只是一个特例。</p><p>你能否既通过递归也能通过迭代来解决该问题。</p><p>既然是DOM Tree，能否提供一个利用到DOM tree特性的解法？</p><p>你的解法的时空复杂度是多少？</p><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">HTMLElement</span>&#125; <span class="hljs-variable">rootA</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">HTMLElement</span>&#125; <span class="hljs-variable">rootB</span> - rootA and rootB are clone of each other</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">HTMLElement</span>&#125; <span class="hljs-variable">nodeA</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">findCorrespondingNode</span> = (<span class="hljs-params">rootA, rootB, target</span>) =&gt; &#123;<br>  <span class="hljs-comment">// your code here</span><br>  <span class="hljs-keyword">if</span>(rootA === target) &#123;<br>    <span class="hljs-keyword">return</span> rootB;<br>  &#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; rootA.<span class="hljs-property">children</span>.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">let</span> found = <span class="hljs-title function_">findCorrespondingNode</span>(rootA.<span class="hljs-property">children</span>[i], rootB.<span class="hljs-property">children</span>[i], target);<br>    <span class="hljs-keyword">if</span>(found) <span class="hljs-keyword">return</span> found;<br>  &#125;<br>&#125;<br><br><br><span class="hljs-comment">// BFS Solution</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">HTMLElement</span>&#125; <span class="hljs-variable">rootA</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">HTMLElement</span>&#125; <span class="hljs-variable">rootB</span> - rootA and rootB are clone of each other</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">HTMLElement</span>&#125; <span class="hljs-variable">nodeA</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">findCorrespondingNode</span> = (<span class="hljs-params">rootA, rootB, target</span>) =&gt; &#123;<br>  <span class="hljs-comment">// your code here</span><br>  <span class="hljs-keyword">if</span> (rootA === target) &#123;<br>    <span class="hljs-keyword">return</span> rootB;<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> queueA = [rootA];<br>  <span class="hljs-keyword">const</span> queueB = [rootB];<br><br>  <span class="hljs-keyword">while</span>(queueA.<span class="hljs-property">length</span>) &#123;<br>    <span class="hljs-keyword">const</span> currentElementA = queueA.<span class="hljs-title function_">shift</span>();<br>    <span class="hljs-keyword">const</span> currentElementB = queueB.<span class="hljs-title function_">shift</span>();<br><br>    <span class="hljs-keyword">if</span> (currentElementA === target) &#123;<br>      <span class="hljs-keyword">return</span> currentElementB;<br>    &#125;<br><br>    queueA.<span class="hljs-title function_">push</span>(...currentElementA.<span class="hljs-property">children</span>);<br>    queueB.<span class="hljs-title function_">push</span>(...currentElementB.<span class="hljs-property">children</span>);    <br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br><br><span class="hljs-comment">// Iterative DFS</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">HTMLElement</span>&#125; <span class="hljs-variable">rootA</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">HTMLElement</span>&#125; <span class="hljs-variable">rootB</span> - rootA and rootB are clone of each other</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">HTMLElement</span>&#125; <span class="hljs-variable">nodeA</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">findCorrespondingNode</span> = (<span class="hljs-params">rootA, rootB, target</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> stack = [[rootA, rootB]];<br>  <span class="hljs-keyword">while</span>(stack.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">const</span> [leftNode, rightNode] = stack.<span class="hljs-title function_">pop</span>();<br>    <span class="hljs-keyword">if</span> (leftNode === target) <span class="hljs-keyword">return</span> rightNode;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; leftNode.<span class="hljs-property">children</span>.<span class="hljs-property">length</span>; i++) &#123;<br>      stack.<span class="hljs-title function_">push</span>([leftNode.<span class="hljs-property">children</span>[i], rightNode.<span class="hljs-property">children</span>[i]]);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="20-检测-data-type"><a href="#20-检测-data-type" class="headerlink" title="20. 检测 data type"></a>20. 检测 data type</h1><p>这是个简单的问题。</p><p>对于JavaScript中的所有<a href="https://javascript.info/types">基础数据类型</a>，请实现一个方法进行检测。</p><p>除了基础数据类型之外，你的方法需要额外支持常见的类型包括<code>Array</code>、<code>ArrayBuffer</code>、<code>Map</code>、 <code>Set</code>、<code>Date</code> 和 <code>Function</code>。</p><p>该题目的目标并不是想要你列举出所有数据类型，而是想要你证明你能解决该类型的问题。</p><p>类型名请返回小写。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">detectType</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// &#x27;number&#x27;</span><br><span class="hljs-title function_">detectType</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()) <span class="hljs-comment">// &#x27;map&#x27;</span><br><span class="hljs-title function_">detectType</span>([]) <span class="hljs-comment">// &#x27;array&#x27;</span><br><span class="hljs-title function_">detectType</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// &#x27;null&#x27;</span><br><br><span class="hljs-comment">// judge的时候会有更多</span><br></code></pre></td></tr></table></figure><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">any</span>&#125; <span class="hljs-variable">data</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">string</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">detectType</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-comment">// your code here</span><br>  <span class="hljs-keyword">if</span>(data <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">FileReader</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;object&#x27;</span>; <span class="hljs-comment">// 面向测试编程</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(data).<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>).<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27; &#x27;</span>)[<span class="hljs-number">1</span>].<span class="hljs-title function_">toLowerCase</span>();<br>&#125;<br><br><span class="hljs-comment">// 用Object.prototype 是因为方法就定义在原型上, 控制台输出 Object 的内容可以查看相关方法</span><br><span class="hljs-comment">// 实例对象中找不到方法，才回去原型上去找，而不是对象的原型属性</span><br></code></pre></td></tr></table></figure><hr><h1 id="21-手写JSON-stringify"><a href="#21-手写JSON-stringify" class="headerlink" title="21. 手写JSON.stringify()"></a>21. 手写JSON.stringify()</h1><p>相信你必定用过<code>JSON.stringify()</code>，你知道它是如何工作的吗？</p><p>请脑补以下其内部逻辑，然后参考 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify">MDN的说明</a>，其实并不简单。</p><p>回到本题目，请实现你自己的<code>JSON.stringify()</code>。</p><p>在真正面试的时候，面试官并不期待你能完全按照spec来实现，请预先和面试官决定需要支持的范围。为了达到练习的目的，该题目将会测试多种数据类型，请尽量考虑周全。</p><p>并请注意循环引用。</p><p><em>注意</em></p><p><code>JSON.stringify()</code> 有额外两个参数，这里并不需要支持。</p><p>不要直接用<code>JSON.stringify()</code>糊弄BFE.dev，这样做并不能帮助你的面试。</p><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">any</span>&#125; <span class="hljs-variable">data</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">string</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">stringify</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-comment">// your code here</span><br>  <span class="hljs-keyword">const</span> type = <span class="hljs-title function_">getType</span>(data);<br>  <span class="hljs-keyword">switch</span>(type) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;string&#x27;</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">`&quot;<span class="hljs-subst">$&#123;data&#125;</span>&quot;`</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;number&#x27;</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;boolean&#x27;</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;data&#125;</span>`</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;null&#x27;</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;undefined&#x27;</span>:    <br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;symbol&#x27;</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;null&#x27;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;function&#x27;</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;date&#x27;</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">`&quot;<span class="hljs-subst">$&#123;data.toISOString()&#125;</span>&quot;`</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;bigint&#x27;</span>:<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;can not stringify &#x27;bigint&#x27; type&quot;</span>);<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;array&#x27;</span>:<br>      <span class="hljs-keyword">const</span> arr = data.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-title function_">stringify</span>(v));<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">`[<span class="hljs-subst">$&#123;arr.join(<span class="hljs-string">&#x27;,&#x27;</span>)&#125;</span>]`</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;object&#x27;</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;map&#x27;</span>:<br>      <span class="hljs-keyword">const</span> items = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(data).<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, cur</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> [key, value] = cur;<br>        <span class="hljs-keyword">if</span>(value === <span class="hljs-literal">undefined</span>) &#123;<br>          <span class="hljs-keyword">return</span> acc;<br>        &#125;<br>        acc.<span class="hljs-title function_">push</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;stringify(key)&#125;</span>:<span class="hljs-subst">$&#123;stringify(value)&#125;</span>`</span>);<br>        <span class="hljs-keyword">return</span> acc;<br>      &#125;, [])<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">`&#123;<span class="hljs-subst">$&#123;items.join(<span class="hljs-string">&#x27;,&#x27;</span>)&#125;</span>&#125;`</span><br><span class="hljs-comment">// 边界符号&#x27; &quot; [ &#123;符号只是给编译器用来识别数据类型用的, 数据才是我们关注的</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getType</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isNaN</span>(data)) &#123; <span class="hljs-comment">// isNaN 针对 NaN 和非数返回true; 而Number.isNaN 针对 NaN 返回true;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;null&#x27;</span>;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(data === <span class="hljs-title class_">Infinity</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;null&#x27;</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(data).<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>).<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27; &#x27;</span>)[<span class="hljs-number">1</span>].<span class="hljs-title function_">toLowerCase</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 面向测试编程的伟大实践</span><br></code></pre></td></tr></table></figure><hr><h1 id="22-手写JSON-parse"><a href="#22-手写JSON-parse" class="headerlink" title="22. 手写JSON.parse()"></a>22. 手写JSON.parse()</h1><p>该问题是 <a href="https://bigfrontend.dev/zh/problem/implement-JSON-stringify">21. 手写JSON.stringify()</a>的后续。</p><p>相信你已经很熟悉<code>JSON.parse()</code>了，你能自己实现一个吗？</p><p>假若你还不熟悉spec的话，可以参考<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse">MDN 的说明</a>，也许会有帮助。</p><p><code>JSON.parse()</code> 支持第二个参数<code>reviver</code>，你可以在本题目中忽略。</p><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">str</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">object | Array | string | number | boolean | null</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">str</span>) &#123;<br>  <span class="hljs-comment">// your code here</span><br>  <span class="hljs-keyword">let</span> result = (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>(<span class="hljs-string">`return <span class="hljs-subst">$&#123;str.replace(/\<span class="hljs-string">&quot;/g, &quot;</span><span class="hljs-string">&#x27;&quot;)&#125;`))();</span></span></span><br><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">  if(str !== JSON.stringify(result)) &#123;</span></span></span><br><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">    throw new Error(&#x27;</span>Has A <span class="hljs-built_in">Error</span><span class="hljs-string">&#x27;);</span></span></span><br><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">  &#125;</span></span></span><br><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">  return result;</span></span></span><br><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">&#125;</span></span></span><br></code></pre></td></tr></table></figure><hr><h1 id="23-实现一个sum-方法"><a href="#23-实现一个sum-方法" class="headerlink" title="23. 实现一个sum()方法"></a>23. 实现一个sum()方法</h1><p>实现一个 <code>sum()</code>，使得如下判断成立。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> sum1 = <span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>)<br><span class="hljs-title function_">sum1</span>(<span class="hljs-number">2</span>) == <span class="hljs-number">3</span> <span class="hljs-comment">// true</span><br><span class="hljs-title function_">sum1</span>(<span class="hljs-number">3</span>) == <span class="hljs-number">4</span> <span class="hljs-comment">// true</span><br><span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>) == <span class="hljs-number">6</span> <span class="hljs-comment">// true</span><br><span class="hljs-title function_">sum</span>(<span class="hljs-number">5</span>)(-<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>) == <span class="hljs-number">6</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">num</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">num</span>) &#123;<br>  <span class="hljs-comment">// your code here</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span> = b =&gt; <span class="hljs-title function_">sum</span>(num + b);<br>  fn[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toPrimitive</span>] = <span class="hljs-function">() =&gt;</span> num;<br>  <span class="hljs-keyword">return</span> fn;<br>&#125;<br><span class="hljs-comment">// 分析：函数既可以和数值进行比较，又可以进行函数调用，那么肯定是在内部的一些特殊属性上做了手脚</span><br></code></pre></td></tr></table></figure><hr><h1 id="24-用JavaScript手写一个Priority-Queue"><a href="#24-用JavaScript手写一个Priority-Queue" class="headerlink" title="24. 用JavaScript手写一个Priority Queue"></a>24. 用JavaScript手写一个Priority Queue</h1><p><a href="https://storm.cis.fordham.edu/~yli/documents/CISC2200Spring15/Graph.pdf">优先队列(Priority Queue)</a> 是在算法题目中经常用到的数据结构。特别是<strong>Top-k</strong>系列问题非常有效，因为它可以避免整体的排序。</p><p>JavaScript中没有原生的优先队列。在真实的面试中，你可以告诉面试官说“假设我们已经又一个优先队列的实现我可以直接使用”，因为没有时间让我们去手写一个优先队列。</p><p>但是这不妨碍优先队列成为一个很好的联手题目，所以请手写一个优先队列！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PriorityQueue</span> &#123;<br>  <span class="hljs-comment">// 构造函数接受一个compare函数</span><br>  <span class="hljs-comment">// compare返回的-1, 0, 1决定元素是否优先被去除</span><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">compare</span>) &#123;<br>  <br>  &#125;<br>  <br>  <span class="hljs-comment">// 添加一个元素</span><br>  <span class="hljs-title function_">add</span>(<span class="hljs-params">element</span>) &#123;<br><br>  &#125;<br><br>  <span class="hljs-comment">// 去除头元素并返回</span><br>  <span class="hljs-title function_">poll</span>(<span class="hljs-params"></span>) &#123;<br>  <br>  &#125;<br><br>  <span class="hljs-comment">// 取得头元素</span><br>  <span class="hljs-title function_">peek</span>(<span class="hljs-params"></span>) &#123;<br><br>  &#125;<br><br>  <span class="hljs-comment">// 取得元素数量</span><br>  <span class="hljs-title function_">size</span>(<span class="hljs-params"></span>) &#123;<br><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以下的例子可能更好理解</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b)<br><span class="hljs-comment">// (a, b) =&gt; a - b 意味着更小的元素排序更靠前</span><br><span class="hljs-comment">// 所以最小的元素首先被去除</span><br><br>pq.<span class="hljs-title function_">add</span>(<span class="hljs-number">5</span>)<br><span class="hljs-comment">// 5是唯一元素</span><br><br>pq.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>)<br><span class="hljs-comment">// 2被添加</span><br><br>pq.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>)<br><span class="hljs-comment">// 1被添加</span><br><br>pq.<span class="hljs-title function_">peek</span>()<br><span class="hljs-comment">//  因为小元素靠前，这里返回1</span><br><br>pq.<span class="hljs-title function_">poll</span>()<br><span class="hljs-comment">// 1 </span><br><span class="hljs-comment">// 1 被去除，剩下2和5</span><br><br>pq.<span class="hljs-title function_">peek</span>()<br><span class="hljs-comment">// 2，此时2是最小</span><br><br>pq.<span class="hljs-title function_">poll</span>()<br><span class="hljs-comment">// 2 </span><br><span class="hljs-comment">// 2被去除，剩下了5</span><br></code></pre></td></tr></table></figure><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// complete the implementation</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PriorityQueue</span> &#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">(a: any, b: any) =&gt; -1 | 0 | 1</span>&#125; <span class="hljs-variable">compare</span> - </span><br><span class="hljs-comment">   * compare function, similar to parameter of Array.prototype.sort</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">compare</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">compare</span> = compare;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = [];<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * return &#123;number&#125; amount of items</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title function_">size</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-property">length</span>;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * returns the head element</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title function_">peek</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[<span class="hljs-number">0</span>];<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">any</span>&#125; <span class="hljs-variable">element</span> - new element to add</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title function_">add</span>(<span class="hljs-params">element</span>) &#123;<br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-title function_">push</span>(element);<br>   <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">compare</span>) &#123;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-title function_">sort</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">compare</span>);<br>   &#125;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * remove the head element</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">any</span>&#125; the head element</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title function_">poll</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-title function_">shift</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 很低效的操作</span><br><span class="hljs-comment">// There are many ways to implement a priority queue</span><br><span class="hljs-comment">// – An unsorted List- dequeuing would require searching</span><br><span class="hljs-comment">// through the entire list – An Array-Based Sorted List- Enqueuing is expensive</span><br><span class="hljs-comment">// – A Linked Sorted List- Enqueuing again is 0(N) – A Binary Search Tree- On average, 0(log2N) steps for</span><br><span class="hljs-comment">//  both enqueue and dequeue</span><br></code></pre></td></tr></table></figure><hr><h1 id="25-更新数组的顺序"><a href="#25-更新数组的顺序" class="headerlink" title="25. 更新数组的顺序"></a>25. 更新数组的顺序</h1><p>假设我们又一个数组<strong>A</strong>，以及另外一个整数数组 <strong>B</strong>.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> A = [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>]<br><span class="hljs-keyword">const</span> B = [<span class="hljs-number">1</span>,   <span class="hljs-number">5</span>,   <span class="hljs-number">4</span>,   <span class="hljs-number">3</span>,   <span class="hljs-number">2</span>,   <span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p>你需要对A进行重新排序，A[i]的新位置将在B[i]，也就是说B是A的各个元素的新索引。</p><p>上述例子进行重排过后，应该得到如下结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-string">&#x27;F&#x27;</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>]<br></code></pre></td></tr></table></figure><p>传入的数据保证是有效的。</p><p><em>继续问问</em></p><p>使用额外的<code>O(n)</code>空间很简单就能完成该题目，你能不实用额外空间完成该题目吗？</p><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">any[]</span>&#125; <span class="hljs-variable">items</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">newOrder</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">void</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sort</span>(<span class="hljs-params">items, newOrder</span>) &#123;<br>  <span class="hljs-comment">// reorder items inline</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key=<span class="hljs-number">0</span>; key&lt;items.<span class="hljs-property">length</span>; key++)&#123;<br>    <span class="hljs-keyword">let</span> value =newOrder[key];<br>    [items[value], items[key]] = [items[key], items[value]];<br>    [newOrder[key], newOrder[value]] = [newOrder[value], newOrder[key]];<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用Object.entries() 就无法获取变换位置后的数组值了</span><br></code></pre></td></tr></table></figure><hr><h1 id="26-实现Object-assign"><a href="#26-实现Object-assign" class="headerlink" title="26. 实现Object.assign()"></a>26. 实现Object.assign()</h1><p><em><code>Object.assign() </code>方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</em> (source: <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">MDN</a>)</p><p>这个方法很常用，实际上<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_syntax">展开语法</a>的内部逻辑和<code>Object.assign()</code> 是一样的(<a href="https://github.com/tc39/proposal-object-rest-spread/blob/master/Spread.md">source</a>)。以下两行代码完全等价。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> aClone = &#123; ...a &#125;;<br><span class="hljs-keyword">let</span> aClone = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, a);<br></code></pre></td></tr></table></figure><p>这是个简单的题目，请自行实现<code>Object.assign()</code>。</p><p><em>注意</em></p><p><strong>不要直接使用Object.assign()</strong> 这不会对你的能力提高有帮助。</p><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">any</span>&#125; <span class="hljs-variable">target</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">any[]</span>&#125; <span class="hljs-variable">sources</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">object</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">objectAssign</span>(<span class="hljs-params">target, ...sources</span>) &#123;<br>  <span class="hljs-comment">// your code here</span><br>  <span class="hljs-keyword">if</span>([<span class="hljs-literal">null</span>, <span class="hljs-literal">undefined</span>].<span class="hljs-title function_">includes</span>(target)) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Expected function to throw an exception.&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>(target);<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> sources) &#123;<br>    <span class="hljs-keyword">if</span>([<span class="hljs-string">&#x27;object&#x27;</span>, <span class="hljs-string">&#x27;string&#x27;</span>, <span class="hljs-string">&#x27;function&#x27;</span>].<span class="hljs-title function_">includes</span>(<span class="hljs-keyword">typeof</span> item) &amp;&amp; item !== <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperties</span>(obj, <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptors</span>(item));<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> obj;<br>&#125;<br><br><span class="hljs-comment">// 这个题目的知识有点冷门</span><br></code></pre></td></tr></table></figure><hr><h1 id="27-实现completeAssign"><a href="#27-实现completeAssign" class="headerlink" title="27. 实现completeAssign()"></a>27. 实现completeAssign()</h1><p>本题是 <a href="https://bigfrontend.dev/zh/problem/implement-object-assign">26. 实现Object.assign()</a>的延续。</p><p><code>Object.assign()</code> 处理的是可枚举属性，所以getters不会被复制，不可枚举属性被忽略。</p><p>假设我们有如下的object。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> source = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<br>  &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">3</span> <span class="hljs-comment">// prototype</span><br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">b</span>: &#123;<br>      <span class="hljs-attr">value</span>: <span class="hljs-number">4</span>,<br>      <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 可枚举 data descriptor</span><br>    &#125;,<br>    <span class="hljs-attr">c</span>: &#123;<br>      <span class="hljs-attr">value</span>: <span class="hljs-number">5</span>, <span class="hljs-comment">// 不可枚举data descriptor</span><br>    &#125;,<br>    <span class="hljs-attr">d</span>: &#123; <span class="hljs-comment">// 不可枚举 accessor descriptor </span><br>      <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_d</span>;<br>      &#125;,<br>      <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">_d</span> = value<br>      &#125;<br>    &#125;,<br>    <span class="hljs-attr">e</span>: &#123; <span class="hljs-comment">// 可枚举 accessor descriptor </span><br>      <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_e</span>;<br>      &#125;,<br>      <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">_e</span> = value<br>      &#125;,<br>      <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span><br>    &#125;<br>  &#125;<br>)<br></code></pre></td></tr></table></figure><p>如果我们调用 <code>Object.assign()</code> 的话，我们得到的是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, source)<br><br><span class="hljs-comment">// &#123;b: 4, e: undefined&#125;</span><br><span class="hljs-comment">// e 是undefined 因为 `this._e` 是undefined</span><br></code></pre></td></tr></table></figure><p>这也许不是我们想要的结果，你能否实现一个<code>completeAssign()</code>，使得data descriptors和 accessor descriptors都能被拷贝？</p><p>如果你还不熟悉descriptors，请参照<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">MDN的说明</a>。</p><p>该问题单纯地想要考考你对descriptors的理解。</p><p>祝你好运！</p><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">completeAssign</span>(<span class="hljs-params">target, ...sources</span>) &#123;<br>  <span class="hljs-keyword">if</span>([<span class="hljs-literal">null</span>, <span class="hljs-literal">undefined</span>].<span class="hljs-title function_">includes</span>(target)) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Expected function to throw an exception.&quot;</span>);<br>  &#125;<br>  target = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>(target);<br>  sources.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">source</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span>([<span class="hljs-string">&#x27;object&#x27;</span>, <span class="hljs-string">&#x27;string&#x27;</span>, <span class="hljs-string">&#x27;function&#x27;</span>].<span class="hljs-title function_">includes</span>(<span class="hljs-keyword">typeof</span> source) &amp;&amp; source !== <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperties</span>(target, <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptors</span>(source));<br>    &#125;<br>  &#125;);<br>  <span class="hljs-keyword">return</span> target;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="28-实现clearAllTimeout"><a href="#28-实现clearAllTimeout" class="headerlink" title="28. 实现clearAllTimeout()"></a>28. 实现clearAllTimeout()</h1><p><code>window.setTimeout()</code> 可以用来设定未来将要执行的任务。</p><p>你能否实现一个<code>clearAllTimeout()</code> 来取消掉所有未执行的timer？比如当页面跳转的时候我们或许想要清除掉所有的timer。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">setTimeout</span>(func1, <span class="hljs-number">10000</span>)<br><span class="hljs-built_in">setTimeout</span>(func2, <span class="hljs-number">10000</span>)<br><span class="hljs-built_in">setTimeout</span>(func3, <span class="hljs-number">10000</span>)<br><br><span class="hljs-comment">// 3个方法都是设定在10秒以后</span><br><span class="hljs-title function_">clearAllTimeout</span>()<br><br><span class="hljs-comment">// 所有方法的timer都被取消掉了</span><br></code></pre></td></tr></table></figure><p><em>注意</em></p><p>你需要保证<code>window.setTimeout</code> 和 <code>window.clearTimeout</code> 还是原来的interface，虽然你可以替换其中的逻辑。</p><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * cancel all timer from window.setTimeout</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">clearAllTimeout</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// your code here</span><br>  timers.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-built_in">clearTimeout</span>(v));<br>&#125;<br><br><span class="hljs-keyword">let</span> timers = [];<br><span class="hljs-keyword">const</span> originTimer = <span class="hljs-built_in">setTimeout</span>;<br><span class="hljs-built_in">setTimeout</span> = <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-title function_">originTimer</span>(...args);<br>  timers.<span class="hljs-title function_">push</span>(timer);<br>  <span class="hljs-keyword">return</span> timer;<br>&#125;<br><br><span class="hljs-comment">// setTimeout、clearTimeout 针对单一事件，要改变它的逻辑，就需要定义一个全局变量保存所有timerId，并且替换原来的setTimeout 的逻辑，</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>做题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bigfrontend 代码题(三)</title>
    <link href="/blog/2021/10/20/bigfrontend-%E4%BB%A3%E7%A0%81%E9%A2%98-%E4%B8%89/"/>
    <url>/blog/2021/10/20/bigfrontend-%E4%BB%A3%E7%A0%81%E9%A2%98-%E4%B8%89/</url>
    
    <content type="html"><![CDATA[<h1 id="8-手写shuffle-随机打乱一个数组"><a href="#8-手写shuffle-随机打乱一个数组" class="headerlink" title="8. 手写shuffle()随机打乱一个数组"></a>8. 手写shuffle()随机打乱一个数组</h1><p>能否手写一个shuffle() ?</p><p>当传入一个数组的时候，shuffle()需要更换元素的顺序，每一种最终的数列都需要被相等的概率生成。</p><p>比如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><p>以上的数组共有4! = 24 中不同的排列</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>]<br>...<br><br><br></code></pre></td></tr></table></figure><p>你写的 <code>shuffle()</code> 需要按照相同的概率(1/24)来返回上述排列中的一种。</p><p><em>注意</em></p><p>你写的 <code>shuffle()</code>会被调用很多次，计算出每一种出现的概率，然后根据<a href="https://zh.wikipedia.org/wiki/%E6%A8%99%E6%BA%96%E5%B7%AE">标准差</a>来判断</p><p>ref: <a href="https://javascript.info/task/shuffle">https://javascript.info/task/shuffle</a></p><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">any[]</span>&#125; <span class="hljs-variable">arr</span></span><br><span class="hljs-comment">  */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">shuffle</span>(<span class="hljs-params">array</span>) &#123;<br>  <span class="hljs-comment">// modify the arr inline to change the order randomly</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = array.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>    <span class="hljs-keyword">let</span> j = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * (i + <span class="hljs-number">1</span>));<br>    [array[i], array[j]] = [array[j], array[i]];<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// function shuffle(array) &#123;</span><br><span class="hljs-comment">//  array.sort(() =&gt; Math.random() - 0.5);</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">// 用这个有问题</span><br><br></code></pre></td></tr></table></figure><hr><h1 id="9-解密消息"><a href="#9-解密消息" class="headerlink" title="9. 解密消息"></a>9. 解密消息</h1><p>在一个字符串的二维数组中，有一个隐藏字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">I B C A L K A<br>D R F C A E A<br>G H O E L A D <br></code></pre></td></tr></table></figure><p>可以按照如下步骤找出隐藏消息</p><ol><li>从左上开始，向右下前进</li><li>无法前进的时候，向右上前进</li><li>无法前进的时候，向右下前进</li><li>2和3的重复</li></ol><p>无法前进的时候，经过的字符就就是隐藏信息</p><p>比如上面的二维数组的话，隐藏消息是<code>IROCLED</code></p><p>注：如果没有的话，返回空字符串</p><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string[][]</span>&#125; <span class="hljs-variable">message</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">string</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">decode</span>(<span class="hljs-params">message</span>) &#123;<br>  <span class="hljs-comment">// your code here</span><br>  <span class="hljs-keyword">let</span> result = <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-keyword">let</span> cols = message[<span class="hljs-number">0</span>]?.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">let</span> direction = <span class="hljs-number">1</span>, i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span>(cols &gt; j) &#123;<br>    result += message[i][j];<br>    <span class="hljs-keyword">if</span>(!message[i+direction]) &#123;<br>      direction *= -<span class="hljs-number">1</span>;<br>    &#125;<br>    i += direction;<br>    j++;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="10-找出第一个不良版本"><a href="#10-找出第一个不良版本" class="headerlink" title="10. 找出第一个不良版本"></a>10. 找出第一个不良版本</h1><p>一个程序有多个版本，不知道什么时候开始有个bug混在其中。请你找到第一个坏掉的版本。</p><p>特定版本是否有bug，可以用<code>isBad(revision)</code>进行判定。</p><p><em>注意</em></p><ol><li>传入的都是非负整数</li><li>如果没有找到，返回-1</li></ol><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 二分法的妙用</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> type TypIsBad = (version: number) =&gt; boolean</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">TypIsBad</span>&#125; isBad </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">firstBadVersion</span>(<span class="hljs-params">isBad</span>) &#123;<br><span class="hljs-comment">// firstBadVersion receive a check function isBad</span><br>  <span class="hljs-comment">// and should return a closure which accepts a version number(integer)</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">version</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// write your code to return the first bad version</span><br>    <span class="hljs-comment">// if none found, return -1</span><br>    <span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> end = version;<br>    <span class="hljs-keyword">while</span>(start &lt;= end) &#123;<br>      <span class="hljs-keyword">let</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((start+end)/<span class="hljs-number">2</span>);<br>      <span class="hljs-keyword">if</span>(<span class="hljs-title function_">isBad</span>(mid)) &#123;<br>        end = mid - <span class="hljs-number">1</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        start = mid + <span class="hljs-number">1</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> start &lt;= version ? start : -<span class="hljs-number">1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="11-什么是Composition-实现pipe"><a href="#11-什么是Composition-实现pipe" class="headerlink" title="11. 什么是Composition?实现pipe()"></a>11. 什么是Composition?实现pipe()</h1><p>什么是Composition? 其实并不难理解，看看<a href="https://whatthefuck.is/composition">@dan_abramov ‘s 的说明</a>就知道了。</p><p>现在需要你自己写一个<code>pipe()</code> 方法。</p><p>假设有一些简单的四则运算方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">times</span> = (<span class="hljs-params">y</span>) =&gt;  <span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x * y<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">plus</span> = (<span class="hljs-params">y</span>) =&gt; <span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x + y<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">subtract</span> = (<span class="hljs-params">y</span>) =&gt; <span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x - y<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">divide</span> = (<span class="hljs-params">y</span>) =&gt; <span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x / y<br></code></pre></td></tr></table></figure><p><code>pipe()</code> 可以用来生成新的计算方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">pipe</span>([<br>  <span class="hljs-title function_">times</span>(<span class="hljs-number">2</span>),<br>  <span class="hljs-title function_">times</span>(<span class="hljs-number">3</span>)<br>])  <br><span class="hljs-comment">// x * 2 * 3</span><br><br><span class="hljs-title function_">pipe</span>([<br>  <span class="hljs-title function_">times</span>(<span class="hljs-number">2</span>),<br>  <span class="hljs-title function_">plus</span>(<span class="hljs-number">3</span>),<br>  <span class="hljs-title function_">times</span>(<span class="hljs-number">4</span>)<br>]) <br><span class="hljs-comment">// (x * 2 + 3) * 4</span><br><br><span class="hljs-title function_">pipe</span>([<br>  <span class="hljs-title function_">times</span>(<span class="hljs-number">2</span>),<br>  <span class="hljs-title function_">subtract</span>(<span class="hljs-number">3</span>),<br>  <span class="hljs-title function_">divide</span>(<span class="hljs-number">4</span>)<br>]) <br><span class="hljs-comment">// (x * 2 - 3) / 4</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong></p><ol><li>为了简单，可以假设传给<code>pipe()</code>的方法都只有一个参数</li></ol><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Array&lt;(arg: any) =&gt; any&gt;</span>&#125; funcs </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">(arg: any) =&gt; any</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">pipe</span>(<span class="hljs-params">funcs</span>) &#123;<br><span class="hljs-comment">// your code here</span><br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">arg</span> =&gt;</span> &#123;<br><span class="hljs-keyword">return</span> funcs.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">result, func</span>) =&gt;</span> &#123;<br><span class="hljs-keyword">return</span> func.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, result);<br>&#125;, arg)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="12-实现-Immutability-helper"><a href="#12-实现-Immutability-helper" class="headerlink" title="12. 实现 Immutability helper"></a>12. 实现 Immutability helper</h1><p>如果你使用React，你肯定会遇到想要修改state的一部分的情况。</p><p>比如下面的state。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> state = &#123;<br>  <span class="hljs-attr">a</span>: &#123;<br>    <span class="hljs-attr">b</span>: &#123;<br>      <span class="hljs-attr">c</span>: <span class="hljs-number">1</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">d</span>: <span class="hljs-number">2</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们想要修改<code>d</code>来生成一个新的state，我们可以用 <a href="https://lodash.com/docs/4.17.15#cloneDeep">_.cloneDeep</a>，但是这样没必要因为<code>state.a</code>并不需要被clone。</p><p>一个更好的办法是如下的浅拷贝</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> newState = &#123;<br>  ...state,<br>  <span class="hljs-attr">d</span>: <span class="hljs-number">3</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但是又有了新问题，如果我们同时需要修改<code>c</code>的话，我们需要写很复杂的代码，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> newState = &#123;<br>  ...state,<br>  <span class="hljs-attr">a</span>: &#123;<br>    ...state.<span class="hljs-property">a</span>,<br>    <span class="hljs-attr">b</span>: &#123;<br>       ...state.<span class="hljs-property">b</span>,<br>       <span class="hljs-attr">c</span>: <span class="hljs-number">2</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这显然还不如cloneDeep。</p><p><a href="https://reactjs.org/docs/update.html">Immutability Helper</a> 可以很好的解决这个问题。</p><p>请实现你自己的Immutability helper <code>update()</code>，需要支持如下调用</p><h3 id="1-push-array-添加元素到数组"><a href="#1-push-array-添加元素到数组" class="headerlink" title="1. {$push: array} 添加元素到数组"></a>1. <code>&#123;$push: array&#125;</code> 添加元素到数组</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><span class="hljs-keyword">const</span> newArr = <span class="hljs-title function_">update</span>(arr, &#123;<span class="hljs-attr">$push</span>: [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>]&#125;)<br><span class="hljs-comment">// [1, 2, 3, 4, 5, 6]</span><br></code></pre></td></tr></table></figure><h3 id="2-set-any-修改目标"><a href="#2-set-any-修改目标" class="headerlink" title="2. {$set: any} 修改目标"></a>2. {$set: any} 修改目标</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> state = &#123;<br>  <span class="hljs-attr">a</span>: &#123;<br>    <span class="hljs-attr">b</span>: &#123;<br>      <span class="hljs-attr">c</span>: <span class="hljs-number">1</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">d</span>: <span class="hljs-number">2</span><br>&#125;<br><br><span class="hljs-keyword">const</span> newState = <span class="hljs-title function_">update</span>(<br>  state, <br>  &#123;<span class="hljs-attr">a</span>: &#123;<span class="hljs-attr">b</span>: &#123; <span class="hljs-attr">c</span>: &#123;<span class="hljs-attr">$set</span>: <span class="hljs-number">3</span>&#125;&#125;&#125;&#125;<br>)<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">  a: &#123;</span><br><span class="hljs-comment">    b: &#123;</span><br><span class="hljs-comment">      c: 3</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">  &#125;,</span><br><span class="hljs-comment">  d: 2</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>注意我们可以通过<code>$set</code>来修改数组中的元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><span class="hljs-keyword">const</span> newArr = <span class="hljs-title function_">update</span>(<br>  arr, <br>  &#123;<span class="hljs-number">0</span>: &#123;<span class="hljs-attr">$set</span>: <span class="hljs-number">0</span>&#125;&#125;<br>)<br><span class="hljs-comment">//  [0, 2, 3, 4]</span><br></code></pre></td></tr></table></figure><h3 id="3-merge-object-合并到目标object"><a href="#3-merge-object-合并到目标object" class="headerlink" title="3. {$merge: object} 合并到目标object"></a>3. {$merge: object} 合并到目标object</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> state = &#123;<br>  <span class="hljs-attr">a</span>: &#123;<br>    <span class="hljs-attr">b</span>: &#123;<br>      <span class="hljs-attr">c</span>: <span class="hljs-number">1</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">d</span>: <span class="hljs-number">2</span><br>&#125;<br><br><span class="hljs-keyword">const</span> newState = <span class="hljs-title function_">update</span>(<br>  state, <br>  &#123;<span class="hljs-attr">a</span>: &#123;<span class="hljs-attr">b</span>: &#123; <span class="hljs-attr">$merge</span>: &#123;<span class="hljs-attr">e</span>: <span class="hljs-number">5</span>&#125;&#125;&#125;&#125;<br>)<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">  a: &#123;</span><br><span class="hljs-comment">    b: &#123;</span><br><span class="hljs-comment">      c: 1,</span><br><span class="hljs-comment">      e: 5</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">  &#125;,</span><br><span class="hljs-comment">  d: 2</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="4-apply-function-自定义修改"><a href="#4-apply-function-自定义修改" class="headerlink" title="4. {$apply: function} 自定义修改"></a>4. {$apply: function} 自定义修改</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><span class="hljs-keyword">const</span> newArr = <span class="hljs-title function_">update</span>(arr, &#123;<span class="hljs-number">0</span>: &#123;<span class="hljs-attr">$apply</span>: <span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> item * <span class="hljs-number">2</span>&#125;&#125;)<br><span class="hljs-comment">// [2, 2, 3, 4]</span><br></code></pre></td></tr></table></figure><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">any</span>&#125; <span class="hljs-variable">data</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Object</span>&#125; <span class="hljs-variable">command</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">data, command</span>) &#123;<br>  <span class="hljs-comment">// your code here</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(command)) &#123;<br>    <span class="hljs-keyword">switch</span>(key) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;$push&#x27;</span>:<br>        <span class="hljs-keyword">return</span> [...data, ...value];<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;$set&#x27;</span>:<br>        <span class="hljs-keyword">return</span> value;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;$merge&#x27;</span>:<br>        <span class="hljs-keyword">if</span>(!(data <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>)) &#123;<br>          <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Bad merge&quot;</span>)<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;...data, ...value&#125;;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;$apply&#x27;</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">value</span>(data);<br>      <span class="hljs-attr">default</span>:<br>        <span class="hljs-keyword">if</span>(data <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>) &#123;<br>          <span class="hljs-keyword">const</span> res = [...data]; <span class="hljs-comment">// 做一个拷贝，原数组取值，现数组设置值</span><br>          res[key] = <span class="hljs-title function_">update</span>(data[key], value);<br>          <span class="hljs-keyword">return</span> res;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">return</span> &#123;<br>            ...data,<br>            [key]: <span class="hljs-title function_">update</span>(data[key], value)<br>          &#125;<br>        &#125;<br>    &#125;<br><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 用到了递归，妙啊</span><br></code></pre></td></tr></table></figure><hr><h1 id="13-利用栈-Stack-创建队列-Queue"><a href="#13-利用栈-Stack-创建队列-Queue" class="headerlink" title="13. 利用栈(Stack)创建队列(Queue)"></a>13. 利用栈(Stack)创建队列(Queue)</h1><p>在JavaScript中，我们可以用Array来充作Stack或者Queue.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><br>arr.<span class="hljs-title function_">push</span>(<span class="hljs-number">5</span>) <span class="hljs-comment">// 变为 [1, 2, 3, 4, 5]</span><br>arr.<span class="hljs-title function_">pop</span>() <span class="hljs-comment">// 5, 数组变为 [1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure><p>上述是Stack的用法，以下则是Queue</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><br>arr.<span class="hljs-title function_">push</span>(<span class="hljs-number">5</span>) <span class="hljs-comment">//  [1, 2, 3, 4, 5]</span><br>arr.<span class="hljs-title function_">shift</span>() <span class="hljs-comment">// 1, 现在数组是 [2, 3, 4, 5]</span><br></code></pre></td></tr></table></figure><p>假设你有Stack，包含如下的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span> &#123;<br>  <span class="hljs-title function_">push</span>(<span class="hljs-params">element</span>) &#123; <span class="hljs-comment">/* 添加元素到stack */</span> &#125;<br>  <span class="hljs-title function_">peek</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/* 获取top 元素 */</span> &#125;<br>  <span class="hljs-title function_">pop</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/* 弹出top 元素 */</span>&#125;<br>  <span class="hljs-title function_">size</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/* 获取元素数量 */</span>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>你能否通过只使用Stack实现一个包含如下方法的Queue？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Queue</span> &#123;<br>  <span class="hljs-title function_">enqueue</span>(<span class="hljs-params">element</span>) &#123; <span class="hljs-comment">/* 添加元素到Queue，类似于Array.prototype.push */</span> &#125;<br>  <span class="hljs-title function_">peek</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/* 获取头元素*/</span> &#125;<br>  <span class="hljs-title function_">dequeue</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/* 弹出头元素，类似于Array.prototype.pop */</span> &#125;<br>  <span class="hljs-title function_">size</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/* 获取元素数量 */</span> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>注意</em></p><p>请只使用Stack，不要使用Array。</p><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/* you can use this Class which is bundled together with your code</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">class Stack &#123;</span><br><span class="hljs-comment">  push(element) &#123; // add element to stack &#125;</span><br><span class="hljs-comment">  peek() &#123; // get the top element &#125;</span><br><span class="hljs-comment">  pop() &#123; // remove the top element&#125;</span><br><span class="hljs-comment">  size() &#123; // count of element &#125;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/* Array is disabled in your code */</span><br><br><span class="hljs-comment">// you need to complete the following Class</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Queue</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>();<br>  &#125;<br><br>  <span class="hljs-title function_">enqueue</span>(<span class="hljs-params">element</span>) &#123; <br>    <span class="hljs-comment">// add new element to the rare</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-title function_">push</span>(element);<br>  &#125;<br>  <span class="hljs-title function_">peek</span>(<span class="hljs-params"></span>) &#123; <br>    <span class="hljs-comment">// get the head element</span><br>    <span class="hljs-keyword">let</span> rStack = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_reverse</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>);<br>    <span class="hljs-keyword">let</span> result = rStack.<span class="hljs-title function_">peek</span>();<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_reverse</span>(rStack);<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br>  <span class="hljs-title function_">size</span>(<span class="hljs-params"></span>) &#123; <br>    <span class="hljs-comment">// return count of element</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-title function_">size</span>();<br>  &#125;<br>  <span class="hljs-title function_">dequeue</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// remove the head element</span><br>    <span class="hljs-keyword">let</span> rStack = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_reverse</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>);<br>    <span class="hljs-keyword">let</span> result = rStack.<span class="hljs-title function_">pop</span>();<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_reverse</span>(rStack);<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br><br>  <span class="hljs-title function_">_reverse</span>(<span class="hljs-params">stack</span>) &#123;<br>    <span class="hljs-keyword">let</span> rStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>();<br>    <span class="hljs-keyword">while</span>(stack.<span class="hljs-title function_">size</span>() &gt; <span class="hljs-number">0</span>) &#123;<br>      rStack.<span class="hljs-title function_">push</span>(stack.<span class="hljs-title function_">pop</span>());<br>    &#125;<br>    <span class="hljs-keyword">return</span> rStack;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 记得复习一下函数，对象，类的写法</span><br></code></pre></td></tr></table></figure><hr><h1 id="14-实现memo"><a href="#14-实现memo" class="headerlink" title="14. 实现memo()"></a>14. 实现<code>memo()</code></h1><p><a href="https://whatthefuck.is/memoization">Memoization</a> 是应用广泛的性能优化的手段，如果你开发过React应用，你一定不会对<code>React.memo</code>感到陌生。</p><p>Memoization在算法题目中也经常用到，如果你可以用递归解决某个问题，那么很多时候加上Memoization可以得到更好的解法，甚至最终引导到动态规划的解法。</p><p>那么，请实现你自己的<code>memo()</code> 函数。传入相同的参数的时候，直接返回上一次的结果而不经过计算。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">func</span> = (<span class="hljs-params">arg1, arg2</span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> arg1 + arg2<br>&#125;<br><br><span class="hljs-keyword">const</span> memoed = <span class="hljs-title function_">memo</span>(func)<br><br><span class="hljs-title function_">memoed</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <br><span class="hljs-comment">// 3， func 被调用</span><br><br><span class="hljs-title function_">memoed</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <br><span class="hljs-comment">// 3，func 未被调用 </span><br><br><span class="hljs-title function_">memoed</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)<br><span class="hljs-comment">// 4，新参数，func 被调用</span><br></code></pre></td></tr></table></figure><p>参数有可能不是字符串，所以你的<code>memo()</code>需要能接受第三个决定缓存key的参数，有点类似于<a href="https://lodash.com/docs/4.17.15#memoize">_.memoize()</a> 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> memoed = <span class="hljs-title function_">memo</span>(func, <span class="hljs-function">() =&gt;</span> <span class="hljs-string">&#x27;samekey&#x27;</span>)<br><br><span class="hljs-title function_">memoed</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <br><span class="hljs-comment">// 3，func被调用，缓存key是 &#x27;samekey&#x27;</span><br><br><span class="hljs-title function_">memoed</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <br><span class="hljs-comment">// 3，因为key是一样的，3被直接返回，func未调用</span><br><br><span class="hljs-title function_">memoed</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>) <br><span class="hljs-comment">// 3，因为key是一样的，3被直接返回，func未调用</span><br></code></pre></td></tr></table></figure><p>默认的key可以用<code>Array.from(arguments).join(&#39;_&#39;)</code>。</p><p><em>注意</em></p><p>这是一种空间换时间的优化，在实际面试中，请仔细分析时间空间复杂度。</p><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Function</span>&#125; <span class="hljs-variable">func</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">(args:[]) =&gt; string </span>&#125;  [resolver] - cache key generator</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">memo</span>(<span class="hljs-params">func, resolver</span>) &#123;<br>  <span class="hljs-comment">// your code here</span><br>  <span class="hljs-keyword">const</span> cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">memoried</span>(<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-keyword">const</span> key = <span class="hljs-keyword">typeof</span> resolver === <span class="hljs-string">&#x27;function&#x27;</span> ? resolver.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args) : args.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;_&#x27;</span>);<br>    <span class="hljs-keyword">if</span>(cache.<span class="hljs-title function_">has</span>(key)) &#123;<br>      <span class="hljs-keyword">return</span> cache.<span class="hljs-title function_">get</span>(key);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">let</span> result = func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>      cache.<span class="hljs-title function_">set</span>(key, result);<br>      <span class="hljs-keyword">return</span> result;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="15-实现类似jQuery的DOM-wrapper"><a href="#15-实现类似jQuery的DOM-wrapper" class="headerlink" title="15. 实现类似jQuery的DOM wrapper"></a>15. 实现类似jQuery的DOM wrapper</h1><p>如果你使用过jQuery，你一定不会对下面的代码感到陌生。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&#x27;#button&#x27;</span>)<br>  .<span class="hljs-title function_">css</span>(<span class="hljs-string">&#x27;color&#x27;</span>, <span class="hljs-string">&#x27;#fff&#x27;</span>)<br>  .<span class="hljs-title function_">css</span>(<span class="hljs-string">&#x27;backgroundColor&#x27;</span>, <span class="hljs-string">&#x27;#000&#x27;</span>)<br>  .<span class="hljs-title function_">css</span>(<span class="hljs-string">&#x27;fontWeight&#x27;</span>, <span class="hljs-string">&#x27;bold&#x27;</span>)<br></code></pre></td></tr></table></figure><p>以上的代码把几处更改链接在一起，更改了按钮的背景色和文字颜色。</p><p>链式操作的使用，让代码更具可读性。</p><p>为了让上述代码可用，请实现自己的<code>$()</code>，只需要支持<code>css(propertyName: string, value: any)</code>即可。</p><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">HTMLElement</span>&#125; <span class="hljs-variable">el</span> - element to be wrapped</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">$</span>(<span class="hljs-params">el</span>) &#123;<br>  <span class="hljs-comment">// your code here</span><br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-title function_">css</span>(<span class="hljs-params">prop, value</span>) &#123;<br>      el.<span class="hljs-property">style</span>[prop] = value;<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 对象中的this 指的是自己，函数对象中的this 指的是调用函数的对象</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>做题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bigfrontend 代码题(二)</title>
    <link href="/blog/2021/10/19/bigfrontend%20%E4%BB%A3%E7%A0%81%E9%A2%98(%E4%BA%8C)/"/>
    <url>/blog/2021/10/19/bigfrontend%20%E4%BB%A3%E7%A0%81%E9%A2%98(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<h1 id="4-手写throttle"><a href="#4-手写throttle" class="headerlink" title="4. 手写throttle()"></a>4. 手写throttle()</h1><p>Throttle是web应用中经常用到的技巧，通常情况下你应该使用现有的实现，比如<a href="https://lodash.com/docs/4.17.15#throttle">lodash throttle()</a> 。</p><p>你能够自己实现一个基本的<code>throttle()</code>吗？</p><p>再次说明一下，<code>throttle(func, delay)</code>返回一个function，这个function无论多么频繁地调用，原始的func的调用也不会超过指定的频率。</p><p>比如，这是throttle之前的调用</p><p>─A─B─C─ ─D─ ─ ─ ─ ─ ─ E─ ─F─G</p><p>按照3个单位进行throttle过后</p><p>─A─ ─ ─C─ ─ ─D ─ ─ ─ ─ E─ ─ ─G</p><p>注意到</p><ul><li>A因为不在任何的冷却时间，所以立即被执行</li><li>B被跳过了，因为B和C都在A的冷却时间里。</li></ul><p><strong>注意</strong></p><ol><li>请按照以上spec完成代码。以上逻辑和<code>lodash.throttle()</code>并不完全一致</li><li>因为 <code>window.setTimeout</code> 和 <code>window.clearTimeout</code> 并不精确。所以在test你写的代码的时候，这两个方法会被替换为静态的实现。不过不用担心，interface是一样的。</li></ol><p>大概会按照以下的样子进行代码测试。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> currentTime = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">run</span> = (<span class="hljs-params">input</span>) =&gt; &#123;<br>  currentTime = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">const</span> calls = []<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">func</span> = (<span class="hljs-params">arg</span>) =&gt; &#123;<br>     calls.<span class="hljs-title function_">push</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;arg&#125;</span>@<span class="hljs-subst">$&#123;currentTime&#125;</span>`</span>)<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> throttled = <span class="hljs-title function_">throttle</span>(func, <span class="hljs-number">3</span>)<br>  input.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">call</span>) =&gt;</span> &#123;<br>     <span class="hljs-keyword">const</span> [arg, time] = call.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;@&#x27;</span>)<br>     <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">throttled</span>(arg), time)<br>  &#125;)<br>  <span class="hljs-keyword">return</span> calls<br>&#125;<br><br><span class="hljs-title function_">expect</span>(<span class="hljs-title function_">run</span>([<span class="hljs-string">&#x27;A@0&#x27;</span>, <span class="hljs-string">&#x27;B@2&#x27;</span>, <span class="hljs-string">&#x27;C@3&#x27;</span>])).<span class="hljs-title function_">toEqual</span>([<span class="hljs-string">&#x27;A@0&#x27;</span>, <span class="hljs-string">&#x27;C@3&#x27;</span>])<br></code></pre></td></tr></table></figure><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Function</span>&#125; <span class="hljs-variable">func</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">wait</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">func, wait</span>) &#123;<br>  <span class="hljs-comment">// your code here</span><br>  <span class="hljs-keyword">let</span> timerId, lastArgs;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">throttled</span>(<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-keyword">if</span>(!timerId) &#123;<br>      func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>      timerId = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span>(lastArgs) &#123;<br>          func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, lastArgs); <br>          <span class="hljs-built_in">clearTimeout</span>(timerId);<br>        &#125;<br>      &#125;, wait)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      lastArgs = args;<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// throttle 节流阀，节流，也就是说在一定时间内，只执行一次，冷却时间过后, 再执行下一次事件，在冷却时间内的调用，会被推到定时器时间结束</span><br></code></pre></td></tr></table></figure><hr><h1 id="5-手写throttle-并支持leading-和-trailing"><a href="#5-手写throttle-并支持leading-和-trailing" class="headerlink" title="5. 手写throttle()并支持leading 和 trailing"></a>5. 手写throttle()并支持leading 和 trailing</h1><p>该题目是<a href="https://bigfrontend.dev/zh/problem/implement-basic-throttle">4. 手写throttle()</a>的后续，请先完成第4题。</p><p>本题目中你需要实现一个增强的<code>throttle()</code>，使其支持第三个参数<code>option: &#123;leading: boolean, trailing: boolean&#125;</code></p><ol><li>leading: 是否立即执行</li><li>trailing: 是否在冷却后执行</li></ol><p><a href="https://bigfrontend.dev/zh/problem/implement-basic-throttle()">4. 手写throttle()</a> 实际上是 <code>&#123;leading: true, trailing: true&#125;</code>的特殊情形。</p><p><strong>具体说明</strong></p><p>同样地按照之前的3单位的throttle来举例。</p><p>─A─B─C─ ─D─ ─ ─ ─ ─ ─ E─ ─F─G</p><p>用<code>&#123;leading: true, trailing: true&#125;</code>来throttle后，我们得到</p><p>─A─ ─ ─C─ ─ ─D ─ ─ ─ ─ E─ ─ ─G</p><p>如果是 <code>&#123;leading: false, trailing: true&#125;</code>，A 和 E 被跳过了</p><p>─ ─ ─ ─C─ ─ ─D─ ─ ─ ─ ─ ─ ─G</p><p>如果是 <code>&#123;leading: true, trailing: false&#125;</code>，只有 A D E 被保留</p><p>─A─ ─ ─ ─D─ ─ ─ ─ ─ ─ E</p><p>如果是 <code>&#123;leading: false, trailing: false&#125;</code>，显而易见，什么都不会发生</p><p><strong>注意</strong></p><ol><li>请按照以上spec完成代码。以上逻辑和<code>lodash.throttle()</code>并不完全一致</li><li>因为 <code>window.setTimeout</code> 和 <code>window.clearTimeout</code> 并不精确。所以在test你写的代码的时候，这两个方法会被替换为静态的实现。不过不用担心，interface是一样的。</li></ol><p>大概会按照以下的样子进行代码测试。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> currentTime = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">run</span> = (<span class="hljs-params">input</span>) =&gt; &#123;<br>  currentTime = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">const</span> calls = []<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">func</span> = (<span class="hljs-params">arg</span>) =&gt; &#123;<br>     calls.<span class="hljs-title function_">push</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;arg&#125;</span>@<span class="hljs-subst">$&#123;currentTime&#125;</span>`</span>)<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> throttled = <span class="hljs-title function_">throttle</span>(func, <span class="hljs-number">3</span>)<br>  input.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">call</span>) =&gt;</span> &#123;<br>     <span class="hljs-keyword">const</span> [arg, time] = call.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;@&#x27;</span>)<br>     <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">throttled</span>(arg), time)<br>  &#125;)<br>  <span class="hljs-keyword">return</span> calls<br>&#125;<br><br><span class="hljs-title function_">expect</span>(<span class="hljs-title function_">run</span>([<span class="hljs-string">&#x27;A@0&#x27;</span>, <span class="hljs-string">&#x27;B@2&#x27;</span>, <span class="hljs-string">&#x27;C@3&#x27;</span>])).<span class="hljs-title function_">toEqual</span>([<span class="hljs-string">&#x27;A@0&#x27;</span>, <span class="hljs-string">&#x27;C@3&#x27;</span>])<br></code></pre></td></tr></table></figure><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Function</span>&#125; <span class="hljs-variable">func</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">wait</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">boolean</span>&#125; option.leading</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">boolean</span>&#125; option.trailing</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">func, wait, option = &#123;leading: <span class="hljs-literal">true</span>, trailing: <span class="hljs-literal">true</span>&#125;</span>) &#123;<br>  <span class="hljs-comment">// your code here</span><br>  <span class="hljs-keyword">let</span> timerId, lastArgs;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">throttled</span>(<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">waitFunc</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>      <span class="hljs-keyword">if</span>(option.<span class="hljs-property">trailing</span> &amp;&amp; lastArgs) &#123;<br>        func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, lastArgs);<br>        lastArgs = <span class="hljs-literal">null</span>;<br>        timerId = <span class="hljs-built_in">setTimeout</span>(waitFunc, wait)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        timerId = <span class="hljs-literal">null</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!timerId) &#123;<br>      <span class="hljs-keyword">if</span>(option.<span class="hljs-property">leading</span>) &#123;<br>        func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>      &#125;<br>      timerId = <span class="hljs-built_in">setTimeout</span>(waitFunc, wait);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      lastArgs = args;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 难度还是挺大的，最关键的是要明白，在冷却时间后，要不要再设置定时器</span><br><span class="hljs-comment">// 根据题目要求，根据lastyargs 和trailing 参数，决定是否设置定时器</span><br></code></pre></td></tr></table></figure><hr><h1 id="6-手写debounce"><a href="#6-手写debounce" class="headerlink" title="6. 手写debounce()"></a>6. 手写debounce()</h1><p><strong>Debounce是web应用中经常用到的技巧，通常情况下你应该使用现有的实现，比如<a href="https://lodash.com/docs/4.17.15#debounce">lodash debounce()</a> 。</strong></p><p>你能够自己实现一个基本的<code>debounce()</code>吗？</p><p>比如，在debounce之前如下的调用</p><p>─A─B─C─ ─D─ ─ ─ ─ ─ ─E─ ─F─G</p><p>经过3单位的debounce之后变为了</p><p>─ ─ ─ ─ ─ ─ ─ ─ D ─ ─ ─ ─ ─ ─ ─ ─ ─ G</p><p><strong>注意</strong></p><ol><li>请按照以上spec完成代码。以上逻辑和<code>lodash.debounce()</code>并不完全一致</li><li>因为 <code>window.setTimeout</code> 和 <code>window.clearTimeout</code> 并不精确。所以在test你写的代码的时候，这两个方法会被替换为静态的实现。不过不用担心，interface是一样的。</li></ol><p>大概会按照以下的样子进行代码测试。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> currentTime = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">run</span> = (<span class="hljs-params">input</span>) =&gt; &#123;<br>  currentTime = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">const</span> calls = []<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">func</span> = (<span class="hljs-params">arg</span>) =&gt; &#123;<br>     calls.<span class="hljs-title function_">push</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;arg&#125;</span>@<span class="hljs-subst">$&#123;currentTime&#125;</span>`</span>)<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> throttled = <span class="hljs-title function_">throttle</span>(func, <span class="hljs-number">3</span>)<br>  input.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">call</span>) =&gt;</span> &#123;<br>     <span class="hljs-keyword">const</span> [arg, time] = call.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;@&#x27;</span>)<br>     <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">throttled</span>(arg), time)<br>  &#125;)<br>  <span class="hljs-keyword">return</span> calls<br>&#125;<br><br><span class="hljs-title function_">expect</span>(<span class="hljs-title function_">run</span>([<span class="hljs-string">&#x27;A@0&#x27;</span>, <span class="hljs-string">&#x27;B@2&#x27;</span>, <span class="hljs-string">&#x27;C@3&#x27;</span>])).<span class="hljs-title function_">toEqual</span>([<span class="hljs-string">&#x27;A@0&#x27;</span>, <span class="hljs-string">&#x27;C@3&#x27;</span>])<br></code></pre></td></tr></table></figure><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Function</span>&#125; <span class="hljs-variable">func</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">wait</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">func, wait</span>) &#123;<br>  <span class="hljs-comment">// your code here</span><br>  <span class="hljs-keyword">let</span> timerId, lastArgs;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">debouced</span>(<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">waitFunc</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>      <span class="hljs-keyword">if</span>(!lastArgs) &#123;<br>        func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, lastArgs);<br>        lastArgs = <span class="hljs-literal">null</span>;<br>      &#125;<br>      timerId = <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(timerId) &#123;<br>      lastArgs = args;<br>      <span class="hljs-built_in">clearTimeout</span>(timerId);<br>    &#125;<br>    timerId = <span class="hljs-built_in">setTimeout</span>(waitFunc, wait);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 防抖也是一段时间后，再执行函数，不过冷却时间内有新的事件，那么定时器时间则重新开始计算</span><br></code></pre></td></tr></table></figure><hr><h1 id="7-手写debounce-并支持leading-和-trailing"><a href="#7-手写debounce-并支持leading-和-trailing" class="headerlink" title="7. 手写debounce()并支持leading 和 trailing"></a>7. 手写debounce()并支持leading 和 trailing</h1><p>该题目是<a href="https://bigfrontend.dev/zh/problem/implement-basic-debounce">6. 手写debounce()</a>的延续，请先完成第6题。</p><p>本题目中你需要实现一个增强的<code>debounce()</code>，使其支持第三个参数<code>option: &#123;leading: boolean, trailing: boolean&#125;</code></p><ol><li>leading: 是否立即执行</li><li>trailing: 是否在冷却后执行</li></ol><p><a href="https://bigfrontend.dev/zh/problem/implement-basic-debounce">6. 手写debounce()</a> 实际上是 <code>&#123;leading: false, trailing: true&#125;</code>的特殊情形。</p><p><strong>具体说明</strong></p><p>还是之前的3单位的例子来说明。</p><p>─A─B─C─ ─D─ ─ ─ ─ ─ ─ E─ ─F─G</p><p>用<code>&#123;leading: false, trailing: true&#125;</code>来debounce过后，我们得到：</p><p>─ ─ ─ ─ ─ ─ ─ ─D─ ─ ─ ─ ─ ─ ─ ─ ─ G</p><p>如果是<code>&#123;leading: true, trailing: true&#125;</code>的话：</p><p>─A─ ─ ─ ─ ─ ─ ─D─ ─ ─E─ ─ ─ ─ ─ ─G</p><p>如果是<code>&#123;leading: true, trailing: false&#125;</code>：</p><p>─A─ ─ ─ ─ ─ ─ ─ ─ ─ ─E</p><p>如果是 <code>&#123;leading: false, trailing: false&#125;</code>，当然，什么都不会发生。</p><p><strong>注意</strong></p><ol><li>请按照以上spec完成代码。以上逻辑和<code>lodash.debounce()</code>并不完全一致</li><li>因为 <code>window.setTimeout</code> 和 <code>window.clearTimeout</code> 并不精确。所以在test你写的代码的时候，这两个方法会被替换为静态的实现。不过不用担心，interface是一样的。</li></ol><p>大概会按照以下的样子进行代码测试。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> currentTime = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">run</span> = (<span class="hljs-params">input</span>) =&gt; &#123;<br>  currentTime = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">const</span> calls = []<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">func</span> = (<span class="hljs-params">arg</span>) =&gt; &#123;<br>     calls.<span class="hljs-title function_">push</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;arg&#125;</span>@<span class="hljs-subst">$&#123;currentTime&#125;</span>`</span>)<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> throttled = <span class="hljs-title function_">throttle</span>(func, <span class="hljs-number">3</span>)<br>  input.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">call</span>) =&gt;</span> &#123;<br>     <span class="hljs-keyword">const</span> [arg, time] = call.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;@&#x27;</span>)<br>     <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">throttled</span>(arg), time)<br>  &#125;)<br>  <span class="hljs-keyword">return</span> calls<br>&#125;<br><br><span class="hljs-title function_">expect</span>(<span class="hljs-title function_">run</span>([<span class="hljs-string">&#x27;A@0&#x27;</span>, <span class="hljs-string">&#x27;B@2&#x27;</span>, <span class="hljs-string">&#x27;C@3&#x27;</span>])).<span class="hljs-title function_">toEqual</span>([<span class="hljs-string">&#x27;A@0&#x27;</span>, <span class="hljs-string">&#x27;C@3&#x27;</span>])<br></code></pre></td></tr></table></figure><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Function</span>&#125; <span class="hljs-variable">func</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">wait</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">boolean</span>&#125; option.leading</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">boolean</span>&#125; option.trailing</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">func, wait, option = &#123;leading: <span class="hljs-literal">false</span>, trailing: <span class="hljs-literal">true</span>&#125;</span>) &#123;<br>  <span class="hljs-comment">// your code here</span><br>  <span class="hljs-keyword">let</span> timerId, lastArgs;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">debouced</span>(<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">waitFunc</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>      <span class="hljs-keyword">if</span>(option.<span class="hljs-property">trailing</span>) &#123;<br>        <span class="hljs-keyword">if</span>(lastArgs) &#123;<br>          func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, lastArgs);<br>          lastArgs = <span class="hljs-literal">null</span>;<br>        &#125;<br>      &#125;<br>      timerId = <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(timerId) &#123;<br>      lastArgs = args;<br>      <span class="hljs-built_in">clearTimeout</span>(timerId);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span>(option.<span class="hljs-property">leading</span>) &#123;<br>        func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        lastArgs = args; <span class="hljs-comment">// 陷阱：option.leading 为false, 的时候，冷却时间到了，开头的事件也是要执行的 </span><br>      &#125;<br>    &#125;<br>    timerId = <span class="hljs-built_in">setTimeout</span>(waitFunc, wait);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>做题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bigfrontend 代码题(一)</title>
    <link href="/blog/2021/10/19/bigfrontend%20%E4%BB%A3%E7%A0%81%E9%A2%98(%E4%B8%80)/"/>
    <url>/blog/2021/10/19/bigfrontend%20%E4%BB%A3%E7%A0%81%E9%A2%98(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h1 id="1-实现curry"><a href="#1-实现curry" class="headerlink" title="1. 实现curry()"></a>1. 实现curry()</h1><p><a href="https://en.wikipedia.org/wiki/Currying">柯里化(Currying)</a> 在JavaScript是一个常用的技巧。</p><p>请实现一个<code>curry()</code>方法，接受一个function然后返回一个柯里化过后的function。</p><p>这是一个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">join</span> = (<span class="hljs-params">a, b, c</span>) =&gt; &#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;a&#125;</span>_<span class="hljs-subst">$&#123;b&#125;</span>_<span class="hljs-subst">$&#123;c&#125;</span>`</span><br>&#125;<br><br><span class="hljs-keyword">const</span> curriedJoin = <span class="hljs-title function_">curry</span>(join)<br><br><span class="hljs-title function_">curriedJoin</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// &#x27;1_2_3&#x27;</span><br><br><span class="hljs-title function_">curriedJoin</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// &#x27;1_2_3&#x27;</span><br><br><span class="hljs-title function_">curriedJoin</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)(<span class="hljs-number">3</span>) <span class="hljs-comment">// &#x27;1_2_3&#x27;</span><br></code></pre></td></tr></table></figure><p>阅读更多</p><p><a href="https://javascript.info/currying-partials">https://javascript.info/currying-partials</a></p><p><a href="https://lodash.com/docs/4.17.15#curry">https://lodash.com/docs/4.17.15#curry</a></p><hr><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">curry</span>(<span class="hljs-params">func</span>) &#123;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">curried</span>(<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-keyword">if</span> (args.<span class="hljs-property">length</span> &gt;= func.<span class="hljs-property">length</span>) &#123;<br>      <span class="hljs-keyword">return</span> func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...args2</span>) &#123;<br>        <span class="hljs-keyword">return</span> curried.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args.<span class="hljs-title function_">concat</span>(args2));<br>      &#125;<br>    &#125;<br>  &#125;;<br><br>&#125;<br><span class="hljs-comment">// func.length 指的是函数定义的参数长度</span><br><span class="hljs-comment">// bind，apply，call三者都可以改变函数的this对象指向。</span><br><span class="hljs-comment">// 三者第一个参数都是this要指向的对象，如果如果没有这个参数或参数为undefined或null，则默认指向全局window。</span><br><span class="hljs-comment">// 三者都可以传参，但是apply是数组，而call是参数列表，且apply和call是一次性传入参数，而bind可以分为多次传入。</span><br><span class="hljs-comment">// bind 是返回绑定this之后的函数，便于稍后调用；apply 、call 则是立即执行 。</span><br></code></pre></td></tr></table></figure><p>参考：<a href="https://zhuanlan.zhihu.com/p/82340026">bind，apply，call三者的区别</a></p><hr><h1 id="2-实现支持placeholder的curry"><a href="#2-实现支持placeholder的curry" class="headerlink" title="2. 实现支持placeholder的curry()"></a>2. 实现支持placeholder的curry()</h1><p>该问题紧接着<a href="https://bigfrontend.dev/zh/problem/implement-curry">1. 实现curry()</a>。</p><p>请实现一个支持placeholder的<code>curry()</code>，可以像这样使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span>  <span class="hljs-title function_">join</span> = (<span class="hljs-params">a, b, c</span>) =&gt; &#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;a&#125;</span>_<span class="hljs-subst">$&#123;b&#125;</span>_<span class="hljs-subst">$&#123;c&#125;</span>`</span><br>&#125;<br><br><span class="hljs-keyword">const</span> curriedJoin = <span class="hljs-title function_">curry</span>(join)<br><span class="hljs-keyword">const</span> _ = curry.<span class="hljs-property">placeholder</span><br><br><span class="hljs-title function_">curriedJoin</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// &#x27;1_2_3&#x27;</span><br><br><span class="hljs-title function_">curriedJoin</span>(_, <span class="hljs-number">2</span>)(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// &#x27;1_2_3&#x27;</span><br><br><span class="hljs-title function_">curriedJoin</span>(_, _, _)(<span class="hljs-number">1</span>)(_, <span class="hljs-number">3</span>)(<span class="hljs-number">2</span>) <span class="hljs-comment">// &#x27;1_2_3&#x27;</span><br></code></pre></td></tr></table></figure><p>阅读更多</p><p><a href="https://javascript.info/currying-partials">https://javascript.info/currying-partials</a></p><p><a href="https://lodash.com/docs/4.17.15#curry">https://lodash.com/docs/4.17.15#curry</a></p><p><a href="https://github.com/planttheidea/curriable">https://github.com/planttheidea/curriable</a></p><hr><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type"> Function </span>&#125; <span class="hljs-variable">func</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">curry</span>(<span class="hljs-params">func</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">curried</span>(<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-keyword">const</span> complete = args.<span class="hljs-property">length</span> &gt;= func.<span class="hljs-property">length</span> &amp;&amp; !args.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, func.<span class="hljs-property">length</span>).<span class="hljs-title function_">includes</span>(curry.<span class="hljs-property">placeholder</span>);<br>    <span class="hljs-keyword">if</span>(complete) <span class="hljs-keyword">return</span> func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args)<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...newArgs</span>) &#123;<br>      <span class="hljs-comment">// replace placeholders in args with values from newArgs</span><br>      <span class="hljs-keyword">const</span> res = args.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">arg</span> =&gt;</span> arg === curry.<span class="hljs-property">placeholder</span> &amp;&amp; newArgs.<span class="hljs-property">length</span> ? newArgs.<span class="hljs-title function_">shift</span>() : arg);<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">curried</span>(...res, ...newArgs);<br>    &#125;<br>  &#125;<br>&#125;<br><br>curry.<span class="hljs-property">placeholder</span> = <span class="hljs-title class_">Symbol</span>()<br><span class="hljs-comment">// 很巧妙，用了一个递归的思想</span><br></code></pre></td></tr></table></figure><hr><h1 id="3-实现Array-prototype-flat"><a href="#3-实现Array-prototype-flat" class="headerlink" title="3. 实现Array.prototype.flat()"></a>3. 实现Array.prototype.flat()</h1><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flat">Array.prototype.flat()</a>可以用来扁平化数组。</p><p>你能够自己实现一个flat么？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, [<span class="hljs-number">4</span>]]];<br><br><span class="hljs-title function_">flat</span>(arr)<br><span class="hljs-comment">// [1, 2, 3, [4]]</span><br><br><span class="hljs-title function_">flat</span>(arr, <span class="hljs-number">1</span>)<br><span class="hljs-comment">// [1, 2, 3, [4]]</span><br><br><span class="hljs-title function_">flat</span>(arr, <span class="hljs-number">2</span>)<br><span class="hljs-comment">// [1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure><p><strong>追问</strong></p><p>能否不用递归而用迭代的方式实现？</p><hr><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 递归版本</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type"> Array </span>&#125; <span class="hljs-variable">arr</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type"> number </span>&#125; <span class="hljs-variable">depth</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> &#123;<span class="hljs-type"> Array </span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flat</span>(<span class="hljs-params">arr, depth = <span class="hljs-number">1</span></span>) &#123;<br>  <span class="hljs-comment">// your imeplementation here</span><br>  <span class="hljs-keyword">let</span> result = []<br>  <span class="hljs-keyword">if</span>(depth &gt;= <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> arr) &#123;<br>      <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> item === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>        result = result.<span class="hljs-title function_">concat</span>(<span class="hljs-title function_">flat</span>(item, depth-<span class="hljs-number">1</span>));<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        result.<span class="hljs-title function_">push</span>(item)<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> arr;<br>  &#125;<br><br>&#125;<br><br><span class="hljs-comment">// 迭代版本</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flat</span>(<span class="hljs-params">arr, depth = <span class="hljs-number">1</span></span>) &#123;<br>  <span class="hljs-comment">// [[1,1] [[2],1], [[3, [4]],1]]</span><br>  <span class="hljs-comment">// [[[2],1], [[3, [4]],1]]</span><br>  <span class="hljs-comment">// [[2,0], [[3, [4]],1]]</span><br>  <span class="hljs-comment">// [[[3, [4]],1]]</span><br>  <span class="hljs-comment">// [[3, 0], [[4], 0]]</span><br>  <br>  <span class="hljs-keyword">const</span> result = []<br>  <span class="hljs-keyword">const</span> stack = [...arr.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> ([item, depth]))]<br>  <br>  <span class="hljs-keyword">while</span> (stack.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">const</span> [top, depth] = stack.<span class="hljs-title function_">pop</span>()<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(top) &amp;&amp; depth &gt; <span class="hljs-number">0</span>) &#123;<br>      stack.<span class="hljs-title function_">push</span>(...top.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> ([item, depth - <span class="hljs-number">1</span>])))<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      result.<span class="hljs-title function_">push</span>(top)<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> result.<span class="hljs-title function_">reverse</span>()<br>&#125;<br><span class="hljs-comment">// 这个迭代版本就是把元素一个一个剥开一层都推入stack 中，符合条件的，推入结果数组</span><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    
    <tags>
      
      <tag>做题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通过命令行使用Python</title>
    <link href="/blog/2021/10/18/%E9%80%9A%E8%BF%87%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BD%BF%E7%94%A8Python/"/>
    <url>/blog/2021/10/18/%E9%80%9A%E8%BF%87%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BD%BF%E7%94%A8Python/</url>
    
    <content type="html"><![CDATA[<p>from: <a href="https://docs.python.org/zh-cn/3/using/cmdline.html#">命令行与环境</a></p><h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><p>调用 Python 时，可以指定下列任意选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python [-bBdEhiIOqsSuvVWx?] [-c <span class="hljs-built_in">command</span> | -m module-name | script | - ] [args]<br></code></pre></td></tr></table></figure><p>最常见的用例是启动时执行脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python myscript.py<br></code></pre></td></tr></table></figure><blockquote><p>通过运行 <code>where python</code> 可以查看 <code>python</code> 安装位置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">C:\Users\HP&gt;<span class="hljs-built_in">where</span> python<br>C:\Python27\python.exe<br>C:\Program Files\python\python.exe<br>C:\Users\HP\AppData\Local\Microsoft\WindowsApps\python.exe<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">C:\Users\HP&gt;<span class="hljs-built_in">where</span> py<br>C:\Windows\py.exe<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">C:\Users\HP&gt;<span class="hljs-built_in">where</span> python3<br>C:\Users\HP\AppData\Local\Microsoft\WindowsApps\python3.exe<br></code></pre></td></tr></table></figure><p>不知不觉安装了这么多<code>python</code>！ 😂</p></blockquote><hr><h3 id="接口选项"><a href="#接口选项" class="headerlink" title="接口选项"></a>接口选项</h3><p>解释器接口类似于 UNIX shell，但提供了额外的调用方法:</p><ul><li>用连接到 tty 设备的标准输入调用时，会提示输入并执行命令，<strong>输入 EOF （文件结束符，UNIX 中按 Ctrl-D，Windows 中按 Ctrl-Z, Enter）时终止</strong>。✨✨</li><li>用文件名参数或以标准输入文件调用时，读取，并执行该脚本文件。</li><li>用目录名参数调用时，从该目录读取、执行适当名称的脚本。</li><li>用 <code>-c command</code> 调用时，执行 <em>command</em> 表示的 Python 语句。<em>command</em> 可以包含用换行符分隔的多条语句。注意，前导空白字符在 Python 语句中非常重要！✨✨</li><li>用 <code>-m module-name</code> 调用时，在 Python 模块路径中查找指定的模块，并将其作为脚本执行。✨✨</li></ul><p>非交互模式下，先解析全部输入，再执行。</p><p>接口选项会终结解释器读入的选项列表，所有后续参数都在 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.argv"><code>sys.argv</code></a> 里 – 注意，首个元素，即下标为零的元素（<code>sys.argv[0]</code>）是表示程序来源的字符串</p><h3 id="通用选项"><a href="#通用选项" class="headerlink" title="通用选项"></a>通用选项</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">-?<br>-h<br>--<span class="hljs-built_in">help</span><br><span class="hljs-comment"># 输出所有命令行选项的简介。</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">-V<br>--version<br><span class="hljs-comment"># 输出 Python 版本号并退出</span><br></code></pre></td></tr></table></figure><p>。示例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Python 3.8.0b2+<br></code></pre></td></tr></table></figure><p>输入两次 <code>V</code> 选项时，输出更多构建信息，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">Python 3.8.0b2+ (3.8:0c076caaa8, Apr 20 2019, 21:55:00)<br>[GCC 6.2.0 20161005]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>文档阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript中变量、函数、对象、类的声明方法汇总</title>
    <link href="/blog/2021/09/21/Javascript%E4%B8%AD%E5%8F%98%E9%87%8F%E3%80%81%E5%87%BD%E6%95%B0%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E7%B1%BB%E7%9A%84%E5%A3%B0%E6%98%8E%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/"/>
    <url>/blog/2021/09/21/Javascript%E4%B8%AD%E5%8F%98%E9%87%8F%E3%80%81%E5%87%BD%E6%95%B0%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E7%B1%BB%E7%9A%84%E5%A3%B0%E6%98%8E%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<p><a href="https://zh.javascript.info/variables">变量</a></p><blockquote><p>关注变量的声明符，<code>let</code>、<code>const</code>、<code>var</code> <a href="https://zh.javascript.info/var">旧时的 “var”</a></p><ul><li><code>let</code> — 现代的变量声明方式。</li><li><code>var</code> — 老旧的变量声明方式。一般情况下，我们不会再使用它。但是，我们会在 <a href="https://zh.javascript.info/var">旧时的 “var”</a> 章节介绍 <code>var</code> 和 <code>let</code> 的微妙差别，以防你需要它们。</li><li><code>const</code> — 类似于 <code>let</code>，但是变量的值无法被修改。</li></ul><p>变量的命名：</p><ul><li><p>变量名称必须仅包含字母，数字，符号 <code>$</code> 和 <code>_</code>。</p></li><li><p>首字符必须非数字。</p></li></ul><p>变量的连续声明用逗号分隔</p></blockquote><p><a href="https://zh.javascript.info/function-basics">函数</a></p><blockquote><p>声明方式，function <functionName>([parameters]) { /* code */}</p><ul><li>作为参数传递给函数的值，会被复制到函数的局部变量。</li><li>函数可以访问外部变量。但它只能从内到外起作用。函数外部的代码看不到函数内的局部变量。</li><li>函数可以返回值。如果没有返回值，则其返回的结果是 <code>undefined</code></li></ul><p>函数命名：</p><ul><li>函数名应该清楚地描述函数的功能。当我们在代码中看到一个函数调用时，一个好的函数名能够让我们马上知道这个函数的功能是什么，会返回什么。</li><li>一个函数是一个行为，所以函数名通常是动词。</li><li>目前有许多优秀的函数名前缀，如 <code>create…</code>、<code>show…</code>、<code>get…</code>、<code>check…</code> 等等。使用它们来提示函数的作用吧。</li></ul></blockquote><p><a href="https://zh.javascript.info/object">对象</a></p><blockquote><p>可以用下面两种语法中的任一种来创建一个空的对象（“空柜子”）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>(); <span class="hljs-comment">// “构造函数” 的语法</span><br><span class="hljs-keyword">let</span> user = &#123;&#125;;  <span class="hljs-comment">// “字面量” 的语法</span><br></code></pre></td></tr></table></figure><p>属性命名没有限制。属性名可以是任何字符串或者 symbol（一种特殊的标志符类型，将在后面介绍）。</p><p>其他类型会被自动地转换为字符串，<strong>值可以是任何类型</strong>。</p><p>可以用下面的方法访问属性：</p><ul><li>点符号: <code>obj.property</code>。</li><li>方括号 <code>obj[&quot;property&quot;]</code>，方括号允许从变量中获取键，例如 <code>obj[varWithKey]</code>。</li></ul><p>其他操作：</p><ul><li>删除属性：<code>delete obj.prop</code>。</li><li>**检查是否存在给定键的属性：<code>&quot;key&quot; in obj</code>**。</li><li><strong>遍历对象：<code>for(let key in obj)</code> 循环</strong>。</li></ul><p>JavaScript 中还有很多其他类型的对象：</p><ul><li><code>Array</code> 用于存储有序数据集合，</li><li><code>Date</code> 用于存储时间日期，</li><li><code>Error</code> 用于存储错误信息。</li><li>……等等。</li></ul><p>它们有着各自特别的特性，我们将在后面学习到。有时候大家会说“Array 类型”或“Date 类型”，但其实<strong>它们并不是自身所属的类型，而是属于一个对象类型即 “object”。它们以不同的方式对 “object” 做了一些扩展</strong>。</p></blockquote><p><a href="https://zh.javascript.info/function-object">函数对象</a></p><blockquote><ul><li><code>name</code> —— 函数的名字。通常取自函数定义，但如果函数定义时没设定函数名，JavaScript 会尝试通过函数的上下文猜一个函数名（例如把赋值的变量名取为函数名）。</li><li><code>length</code> —— 函数定义时的入参的个数。Rest 参数不参与计数。</li></ul><p>如果函数是<strong>通过函数表达式的形式被声明的（不是在主代码流里），并且附带了名字，那么它被称为命名函数表达式（Named Function Expression）</strong>。这个名字可以用于在该函数内部进行自调用，例如递归调用等。</p></blockquote><p><a href="https://zh.javascript.info/prototype-inheritance">函数原型</a></p><blockquote><p><a href="https://zh.javascript.info/prototype-inheritance#zong-jie">总结</a></p><ul><li>在 JavaScript 中，所有的对象都有一个隐藏的 <code>[[Prototype]]</code> 属性，它要么是另一个对象，要么就是 <code>null</code>。</li><li>我们可以使用 <code>obj.__proto__</code> 访问它（历史遗留下来的 getter/setter，这儿还有其他方法，很快我们就会讲到）。</li><li>通过 <code>[[Prototype]]</code> 引用的对象被称为“原型”。</li><li>如果我们想要读取 <code>obj</code> 的一个属性或者调用一个方法，并且它不存在，那么 JavaScript 就会尝试在原型中查找它。</li><li>写/删除操作直接在对象上进行，它们不使用原型（假设它是数据属性，不是 setter）。</li><li>如果我们调用 <code>obj.method()</code>，而且 <code>method</code> 是从原型中获取的，<code>this</code> 仍然会引用 <code>obj</code>。因此，方法始终与当前对象一起使用，即使方法是继承的。</li><li><code>for..in</code> 循环在其自身和继承的属性上进行迭代。所有其他的键/值获取方法仅对对象本身起作用。</li></ul></blockquote><p><a href="https://zh.javascript.info/class">类</a></p><blockquote><p>基本的类语法看起来像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>  prop = value; <span class="hljs-comment">// 属性</span><br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">...</span>) &#123; <span class="hljs-comment">// 构造器</span><br>    <span class="hljs-comment">// ...</span><br>  &#125;<br><br>  <span class="hljs-title function_">method</span>(<span class="hljs-params">...</span>) &#123;&#125; <span class="hljs-comment">// method</span><br><br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">something</span>(<span class="hljs-params">...</span>) &#123;&#125; <span class="hljs-comment">// getter 方法</span><br>  <span class="hljs-keyword">set</span> <span class="hljs-title function_">something</span>(<span class="hljs-params">...</span>) &#123;&#125; <span class="hljs-comment">// setter 方法</span><br><br>  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() &#123;&#125; <span class="hljs-comment">// 有计算名称（computed name）的方法（此处为 symbol）</span><br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>技术上来说，<code>MyClass</code> 是一个函数（我们提供作为 <code>constructor</code> 的那个），而 methods、getters 和 settors 都被写入了 <code>MyClass.prototype</code>。</p></blockquote><p>总结一下：</p><blockquote><p><strong>JavaScript 中，一切都是对象</strong>。在一个函数对象中，可以声明基础变量，叫做静态属性，属于这个对象。</p><p>this.[props] 声明的是对象实例化后的公有属性，可以用来进行方法操作。</p><p>方法，又有好几种声明方法，函数式声明，函数表达式声明，对象键值对式的声明。</p><ul><li><p>键值对式的声明，一般用在对象中，作为属性存在；</p></li><li><p>函数声明，用在类中，作为对象原型中的方法存在，在函数对象中，做为私有方法存在；</p></li><li><p>函数表达式，有this，则公有，否，私有的。</p></li></ul></blockquote><p>See see: <a href="https://github.com/Wscats/articles/issues/85">前端程序员经常忽视的一个JavaScript面试题</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>知识汇总</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数的apply、call、bind 方法的区别</title>
    <link href="/blog/2021/09/02/%E5%87%BD%E6%95%B0%E7%9A%84apply%E3%80%81call%E3%80%81bind-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/blog/2021/09/02/%E5%87%BD%E6%95%B0%E7%9A%84apply%E3%80%81call%E3%80%81bind-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>参考：<a href="https://zh.javascript.info/call-apply-decorators">装饰器模式和转发，call/apply</a></p><p><strong>装饰器</strong> 是一个围绕改变函数行为的包装器。主要工作仍由该函数来完成。</p><p>装饰器可以被看作是可以添加到函数的 “features” 或 “aspects”。我们可以添加一个或添加多个。而这一切都无需更改其代码！</p><p>为了实现 <code>cachingDecorator</code>，我们研究了以下方法：</p><ul><li><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Function/call">func.call(context, arg1, arg2…)</a> —— 用给定的上下文和参数调用 <code>func</code>。也就是说，<strong>将传进来的context 对象作为函数的调用对象</strong>；</li><li><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Function/apply">func.apply(context, args)</a> —— 调用 <code>func</code> 将 <code>context</code> 作为 <code>this</code> 和类数组的 <code>args</code> 传递给参数列表。</li></ul><p>通用的 <strong>呼叫转移（call forwarding）</strong> 通常是使用 <code>apply</code> 完成的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> wrapper = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> original.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们也可以看到一个 <strong>方法借用（method borrowing）</strong> 的例子，就是我们从一个对象中获取一个方法，并在另一个对象的上下文中“调用”它。采用数组方法并将它们应用于参数 <code>arguments</code> 是很常见的。另一种方法是使用 Rest 参数对象，该对象是一个真正的数组。</p><hr><p>call:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">(method) <span class="hljs-title class_">Function</span>.<span class="hljs-title function_">call</span>(<span class="hljs-attr">this</span>: <span class="hljs-title class_">Function</span>, <span class="hljs-attr">thisArg</span>: any, ...<span class="hljs-attr">argArray</span>: any[]): any<br><br><span class="hljs-title class_">Calls</span> a method <span class="hljs-keyword">of</span> an object, substituting another object <span class="hljs-keyword">for</span> the current object. <span class="hljs-comment">// 引用一个对象的方法，把那个对象替换为当前对象（传进来的那个）</span><br><br>@param thisArg — <span class="hljs-title class_">The</span> object to be used <span class="hljs-keyword">as</span> the current object.<br><br>@param argArray — A list <span class="hljs-keyword">of</span> <span class="hljs-variable language_">arguments</span> to be passed to the method.<br></code></pre></td></tr></table></figure><p>apply:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">(method) <span class="hljs-title class_">Function</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-attr">this</span>: <span class="hljs-title class_">Function</span>, <span class="hljs-attr">thisArg</span>: any, argArray?: any): any<br><span class="hljs-title class_">Calls</span> the <span class="hljs-keyword">function</span>, substituting the specified object <span class="hljs-keyword">for</span> the <span class="hljs-variable language_">this</span> value <span class="hljs-keyword">of</span> the <span class="hljs-keyword">function</span>, and the specified array <span class="hljs-keyword">for</span> the <span class="hljs-variable language_">arguments</span> <span class="hljs-keyword">of</span> the <span class="hljs-keyword">function</span>. <span class="hljs-comment">// 引用函数值，替换函数的this 为指定的对象。指定数组作为函数的参数</span><br><br>@param thisArg — <span class="hljs-title class_">The</span> object to be used <span class="hljs-keyword">as</span> the <span class="hljs-variable language_">this</span> object.<br><br>@param argArray — A set <span class="hljs-keyword">of</span> <span class="hljs-variable language_">arguments</span> to be passed to the <span class="hljs-keyword">function</span>.<br></code></pre></td></tr></table></figure><p>bind:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">(method) <span class="hljs-title class_">Function</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-attr">this</span>: <span class="hljs-title class_">Function</span>, <span class="hljs-attr">thisArg</span>: any, ...<span class="hljs-attr">argArray</span>: any[]): any<br><span class="hljs-title class_">For</span> a given <span class="hljs-keyword">function</span>, creates a bound <span class="hljs-keyword">function</span> that has the same body <span class="hljs-keyword">as</span> the original <span class="hljs-keyword">function</span>. <span class="hljs-title class_">The</span> <span class="hljs-variable language_">this</span> object <span class="hljs-keyword">of</span> the bound <span class="hljs-keyword">function</span> is associated <span class="hljs-keyword">with</span> the specified object, and has the specified initial parameters. <span class="hljs-comment">// 对于被给定的函数，创建一个和原始函数有相同主体的绑定了的函数，这个绑定了的函数和指定的对象相关联，有着明确的初始化参数。</span><br><br>@paramthisArg — <span class="hljs-title class_">An</span> object to which the <span class="hljs-variable language_">this</span> keyword can refer inside the <span class="hljs-keyword">new</span> <span class="hljs-keyword">function</span>.<br><br>@paramargArray — A list <span class="hljs-keyword">of</span> <span class="hljs-variable language_">arguments</span> to be passed to the <span class="hljs-keyword">new</span> <span class="hljs-keyword">function</span>.<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>知识总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言中的*和&amp;</title>
    <link href="/blog/2021/08/07/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84-%E5%92%8C/"/>
    <url>/blog/2021/08/07/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84-%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="What’s-the-difference-between-and-amp-in-C"><a href="#What’s-the-difference-between-and-amp-in-C" class="headerlink" title="What’s the difference between * and &amp; in C?"></a><a href="https://stackoverflow.com/questions/28778625/whats-the-difference-between-and-in-c">What’s the difference between * and &amp; in C?</a></h1><p><code>*</code> 和 <code>&amp;</code> 作为<strong>类型修饰符</strong>：</p><ul><li><p><code>int i</code> 声明一个整数类型变量 <code>i</code></p></li><li><p><code>int* p</code> 声明一个指向整数类型变量的指针 <code>p</code></p></li><li><p><code>int&amp; r = i</code> 声明一个对整数类型变量的引用，并且这个变量为 <code>i</code>. （仅用在C++ 中，注意引用必须在初始化的时候进行赋值；因此 <code>int&amp; i;</code> 是不存在的）</p><p>类似的就有：</p></li><li><p><code>void foo(int i)</code> 声明一个函数，以整数类型变量为参数（作为一个副本，按值传递）</p></li><li><p><code>void foo(int* p)</code> 声明一个函数，以一个指向整数类型变量的指针（整型指针）为参数</p></li><li><p><code>void foo(int&amp; r)</code> 声明一个函数，以整数类型变量的引用为参数（仅用在C++ 中）</p></li></ul><hr><p><code>*</code> 和 <code>&amp;</code> 作为<strong>操作符</strong>：</p><ul><li><p><code>foo(i)</code> 调用 <code>foo(int)</code>. 参数通过值的副本传递</p></li><li><p><code>foo(*p)</code> 去掉指针变量 <code>p</code> 的引用，用被 <code>p</code> 指向的整数作为参数去调用 <code>foo(int)</code> </p></li><li><p><code>foo(&amp;i)</code> 以整数类型变量 <code>i</code> 的地址为参数，用变量的地址为参数调用 <code>foo(int*)</code> （意思就是说，你要一个变量引用，我就声明一个整型指针给你）</p><hr></li></ul><p>（tl;dr）太长不看版本，简而言之，符号的作用取决于上下文环境：</p><ul><li><code>*</code> 既可以作为 去掉指针引用的操作符，也可以作为指针声明符的一部分；</li><li><code>&amp;</code> 可以作为取地址操作符，在C++ 中还可以作为引用声明符的一部分；</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>学习总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>技术学习方法总结</title>
    <link href="/blog/2021/08/01/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    <url>/blog/2021/08/01/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>我主张，在具备基础之后，学习任何新东西，都要抓住主线，突出重点。对于关键理论的学习，要集中精力，速战速决。而旁枝末节和非本质性的知识内容，完全可以留给实践去零敲碎打。</p><p>原因是这样的，任何一个高级的知识内容，其中都只有一小部分是有思想创新、有重大影响的，而其它很多东西都是琐碎的、非本质的。因此，集中学习时必须把握住真正重要那部分，把其它东西留给实践。对于重点知识，只有集中学习其理论，才能确保体系性、连贯性、正确性，而对于那些旁枝末节，只有边干边学能够让你了解它们的真实价值是大是小，才能让你留下更生动的印象。如果你把精力用错了地方，比如用集中大块的时间来学习那些本来只需要查查手册就可以明白的小技巧，而对于真正重要的、思想性东西放在平时零敲碎打，那么肯定是事倍功半，甚至适得其反。</p><p>因此我对于市面上绝大部分开发类图书都不满——它们基本上都是面向知识体系本身的，而不是面向读者的。总是把相关的所有知识细节都放在一堆，然后一堆一堆攒起来变成一本书。反映在内容上，就是毫无重点地平铺直叙，不分轻重地陈述细节，往往在第三章以前就用无聊的细节谋杀了读者的热情。为什么当年侯捷先生的《深入浅出MFC》和 Scott Meyers 的 Effective C++ 能够成为经典？就在于这两本书抓住了各自领域中的主干，提纲挈领，纲举目张，一下子打通读者的任督二脉。可惜这样的书太少，就算是已故 Richard Stevens 和当今 Jeffrey Richter 的书，也只是在体系性和深入性上高人一头，并不是面向读者的书。</p><p>最近我闲逛各技术社区，最深的一个感受，就是开发者的niubility value也跟中国社会的 income distribution 一样，呈现严重的两极分化状态。所以我建议那些老鸟们，多做一点提纲挈领的总结工作，把真正紧要的东西总结出来，给社区一些贡献。<br>————————————————<br>版权声明：本文为CSDN博主「myan」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/myan/article/details/5877305">https://blog.csdn.net/myan/article/details/5877305</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>方法总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编程语言学习方法</title>
    <link href="/blog/2021/07/25/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    <url>/blog/2021/07/25/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>现在的开发工作要求我们能够快速掌握一门语言。一般来说应对这种挑战有两种态度：其一，粗粗看看语法，就撸起袖子开干，边查Google边学习；其二是花很多时间完整地把整个语言学习一遍，做到胸有成竹，然后再开始做实际工作。然而这两种方法都有弊病。第二种方法的问题当然很明显，不仅浪费了时间，偏离了目标，而且学习效率不高。因为没有实际问题驱动的语言学习通常是不牢固不深入的。有的人学着学着成了语言专家，反而忘了自己原本是要解决问题来的。第一种路子也有问题，在对于这种语言的脾气秉性还没有了解的情况下大刀阔斧地拼凑代码，写出来的东西肯定不入流。说穿新鞋走老路，新瓶装旧酒，那都是小问题，真正严重的是这样的程序员可以在短时间内堆积大量充满缺陷的垃圾代码。由于通常开发阶段的测试完备程度有限，这些垃圾代码往往能通过这个阶段，从而潜伏下来，在后期成为整个项目的毒瘤，反反复复让后来的维护者陷入西西弗斯困境。</p><p>实际上语言学习有一定规律可循，对于已经掌握一门语言的开发者来说，对于一般的语言，完全可以以最快的速度，在几天至一周之内掌握其最常用的50%，而且保证路子基本正宗，没有出偏的弊病。其实真正写程序不怕完全不会，最怕一知半解的去攒解决方案。因为你完全不会，就自然会去认真查书学习，如果学习能力好的话，写出来的代码质量不会差。而一知半解，自己动手土法炼钢，那搞出来的基本上都是废铜烂铁。比如错误处理和序列化，很多人不去了解“正路子”，而是凭借自己的一知半解去攒野路子，这是最危险的。因此，即使时间再紧张，这些内容也是必须首先完整了解一遍的。掌握这些内容之后进入实际开发，即使有问题，也基本不会伤及项目大体。而开发者本人则可以安步当车，慢慢在实践中提高自己。</p><p>以下列出一个学习提纲，主要针对的是有经验的人，初学者不合适。这个提纲只能用于一般的庸俗编程语言学习，目前在流行编程语言排行榜上排前20的基本上都是庸俗语言。如果你要学的是LISP之类非庸俗语言，或是某个软件中的二次开发语言，这里的建议未必合适。还是那句话，仅供参考。</p><ol><li><p>首先<strong><font color="#0000ff">了解该语言的基本数据类型，基本语法和主要语言构造</font></strong>，主要数学运算符和print函数的使用，达到能够写谭浩强程序设计书课后数学习题的程度；</p></li><li><p>其次<strong><font color="#0000ff">其次掌握数组和其他集合类的使用</font></strong>，有基础的话可以理解一下泛型，如果理解不了也问题不大，后面可以补；</p></li><li><p>简单字符串处理。所谓简单，就是Regex和Parser以下的内容，什么查找替换，截断去字串之类的。不过这个阶段有一个难点，就是字符编码问题。如果理解不了，可以先跳过，否则的话最好在这时候把这个问题搞定，免留后患；</p></li><li><p><strong><font color="#0000ff">基本面向对象或者函数式编程的特征</font></strong>，无非是什么继承、多态、Lambda函数之类的，如果有经验的话很快就明白了；</p></li><li><p><strong><font color="#0000ff">异常、错误处理、断言、日志和调试支持，对单元测试的支持</font></strong>。你不一定要用TDD，但是在这个时候应该掌握在这个语言里做TDD的基本技能；</p></li><li><p><strong><font color="#0000ff">程序代码和可执行代码的组织机制，运行时模块加载、符号查找机制</font></strong>，这是初学时的一个难点，因为大部分书都不太注意介绍这个极为重要的内容；</p></li><li><p><strong><font color="#0000ff">基本输入输出和文件处理，输入输出流类的组织</font></strong>，这通常是比较繁琐的一部分，可以提纲挈领学一下，搞清楚概念，用到的时候查就是了。到这个阶段可以写大部分控制台应用了；</p></li><li><p><strong><font color="#0000ff">该语言如何进行callback方法调用，如何支持事件驱动编程模型。</font></strong>。在现代编程环境下，这个问题是涉及开发思想的一个核心问题，几乎每种语言在这里都会用足功夫，.NET的delegate，Java的anonymous inner class，Java 7的closure，C++OX的 tr1::function/bind，五花八门。如果能彻底理解这个问题，不但程序就不至于写得太走样，而且对该语言的设计思路也能有比较好的认识；</p></li><li><p>如果有必要，可在这时研究regex和XML处理问题，如无必要可跳过；</p></li><li><p><strong><font color="#0000ff">序列化和反序列化</font></strong>，掌握一下缺省的机制就可以了；</p></li><li><p>如果必要，可了解一下线程、并发和异步调用机制，主要是为了读懂别人的代码，如果自己要写这类代码，必须专门花时间严肃认真系统地学习，严禁半桶水上阵；</p></li><li><p>动态编程，反射和元数据编程，数据和程序之间的相互转化机制，运行时编译和执行的机制，有抱负的开发者在这块可以多下些功夫，能够使你对语言的认识高出一个层面；</p></li><li><p>如果有必要，可研究一下该语言对于泛型的支持，不必花太多时间，只要能使用现成的泛型集合和泛型函数就可以了，可在以后闲暇时抽时间系统学习。需要注意的是，泛型技术跟多线程技术一样，用不好就成为万恶之源，必须系统学习，谨慎使用，否则不如不学不用；</p></li><li><p>如果还有时间，最好咨询一下有经验的人，看看这个语言较常用的特色features是什么，如果之前没学过，应当补一下。比如Ruby的block interator, Java的dynamic proxy，C# 3的LINQ和extension method。没时间的话，我认为也可以边做边学，没有大问题。</p></li><li><p>有必要的话，在工作的闲暇时间，可以着重考察两个问题，第一，这个语言有哪些惯用法和模式，第二，这个语言的编译/解释执行机制。</p></li></ol><p>至此语言的基本部分就可以说掌握了，之后是做数据库、网络还是做图形，可以根据具体需求去搞，找相应的成熟框架或库，边做边学，加深理解。对于一个庸俗语言，我自己把上面的内容走一遍大概要花2-3周时间，不能算很快，但也耽误不了太多事情，毕竟不是每个月都学新语言。掌握了以上的内容，就给练武术打好了基本功，虽然不见得有多优秀，但是肯定是根正苗红，将来不必绕大弯子。就算是临时使用的语言，把上面这个提纲精简一下，只看蓝色重体字的部分，大致能在几天到一周内搞定，不算是太耗时，而且写出来的代码不会太不靠谱。</p><p>以上提纲未设及内存模型。对于C/C++，这个问题很重要，要放在显著位置来考虑，但对于其他语言，这个问题被透明化了，除非你要做hardcore项目，否则不必太关注。<br>————————————————<br>版权声明：本文为CSDN博主「myan」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/myan/article/details/3144661">https://blog.csdn.net/myan/article/details/3144661</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>方法总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>英语学习方法</title>
    <link href="/blog/2021/07/18/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    <url>/blog/2021/07/18/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p> 来源：<a href="https://zhuanlan.zhihu.com/p/24665519">学好英文的十个步骤</a></p><p>之前我们已经看到了，学会英文可以帮你节约至少600块钱（最多可以到7300人民币）。如此巨大的收益，让人们不禁要问：我如何才能学会英文呢？</p><p>学会英文很简单；你学会了汉语自然就表明你有能力学会英文。下面我们就来列出大纲描绘一下学习英文的几个基本阶段：</p><p>注意：虽然是大纲性质，也是21分钟就能看完的，但这篇文章是不收钱的。原因很简单，因为大部分人就算看懂了以下步骤，英文也是学不会的。从效果来说，就好像学会了C++你也找不到工作，这样怎么能收费呢？逃。。。）</p><p><strong>前置条件：</strong></p><p>你的英文词汇量已经达到高三人教版教材要求的水平，也就是掌握英文常用单词数目2000个。如果你还没达到，建议你退学重读高一。我有很多高中可以推荐，例如郴州市明星学校。需要的可以私信我。</p><p>这2000个单词，我分为如下几个部分：</p><ol><li><p>1000个名词；重要生活物件的名词，表述思维的抽象名词等。apple，orange 当然是需要的；inspiration, sabotage 也是需要的。</p></li><li><p>250个动词；描述任意动作和抽象动作。do，make是需要的；reinforce, heighten 更是需要的。</p></li><li><p>250个副词；修辞动作。happily， luckily 当然是需要的；figuratively, ubiquitously 也是需要的；</p></li><li><p>500个形容词；修辞名词。big，large当然是需要的；blunt, riveting 更是需要的。</p></li></ol><p><strong>步骤一：</strong></p><p>学会基本的语法。我建议买一本【薄冰英语语法】来看。千万不要听高中老师胡说八道。</p><p>下面是几个例子：</p><ol><li><p>理解为什么 there is a woman swallowing banana 里面的swallowing 必须是ing形式；</p></li><li><p>理解为什么 Do you know where he heads 里面的 heads 后面为什么不加 to；</p></li><li><p>理解为什么 Given time, we would heal 里面的 given 为什么不是 giving；</p></li><li><p>理解为什么 Why you always take things for granted 里面的 granted 要用被动。</p></li></ol><p><strong>步骤二：</strong></p><p>买一本英英词典（例如牛津词典），并且把你的汉英、英汉词典烧掉；该辞典的好处是用2000个常用字解释所有词条。每次看见新单词请打开这本辞典找到词条，用你的语法知识和单词量理解这个词。</p><p><strong>步骤三：</strong></p><p>使用学会的单词；看到一个学会的新单词，例如unanimously，你觉得太罕见不会用；不是的，请看他在词典中的例句，把例句背下来。</p><p><strong>步骤四：</strong></p><p>参加校园英语角，在英语角里面疯狂使用辞典例句，并且虚构故事，吓死他们。。逃）</p><p><strong>步骤五：</strong></p><p>上一个步骤是虚构的；在现实生活中，充分使用学习到的例句；例如早上起来了你要说什么？交作业忘记写了你要说什么？食堂打饭你要说什么？洗澡你要说什么？OOXX你要说什么？就这个意思。</p><p><strong>步骤六：</strong></p><p>用英文的逻辑改造你的思维。基于步骤五，你已经可以完全使用英文进行思考了。语言决定了你的思维能力；在思考的过程中，你会进一步具象化英文中的名词，动词，词组等；并且连接你听说读写之功能。因为说白了，听说读写的核心其实是让你用英文想。如果你都必须用中文想，说一口标准的大白东北英语，那你还是放弃治疗吧。</p><p><strong>步骤七：</strong></p><p>准备一个记录本，把你认为有用的动词，副词，形容词和名词按照这样的顺序（动副形名的顺序，因为他们在语言中的重要性依次递减）记录下来；方便日后参照。使用任何一种记忆法防止你忘记（一般来说忘记3次之后你就不会忘记了）。除非你过目不忘，这种形式还是很重要的。</p><p><strong>步骤八：</strong></p><p>买一本适合自己词汇量的英文杂志，例如空中英语教室。另外找一本新概念英语或者本科英语教材每天早上按照要求背诵一下。其实这都不重要，关键是把你字典上学会的东西找个地方用起来。</p><p><strong>步骤九：</strong></p><p>买一本Economist自己看，或者看Friends的英文原版英文字幕。尝试用英文开始写总结。其实这都不重要。对于程序员来说，能看懂就可以了，不需要写==</p><p><strong>步骤十：</strong></p><p>坚持1年。学完一年之后，相信你就可以自己去看C++ PRIMER了。另外，你不会还不知道PRIMER啥意思把。去看牛津词典，然后找那个例句自己练习100次。。</p><hr><p>曾老师的方法，核心在于 <strong>学以致用</strong>。</p><p>多数人在学习英语的过程中，一个常见的误区就是陷入单词和语法的细节地狱，这也可以看作是一个巨大的舒适区。当遇到问题时，不会从实践角度出发，理解问题，反而一头扎进单词语法的海洋中去了。我听不懂英语听力，那肯定是我词汇量不够；我看不懂英文文章，那肯定是我词汇量不够；我不会表达，那肯定是我词汇量不够；我写不出地道的英文文章，那肯定是我词汇量不够。彷佛一切都可以归结到词汇量不够这个问题上来了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>方法总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《计算机系统要素》一书中的名人名言</title>
    <link href="/blog/2021/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%A6%81%E7%B4%A0%E4%B8%80%E4%B9%A6%E4%B8%AD%E7%9A%84%E5%90%8D%E4%BA%BA%E5%90%8D%E8%A8%80/"/>
    <url>/blog/2021/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%A6%81%E7%B4%A0%E4%B8%80%E4%B9%A6%E4%B8%AD%E7%9A%84%E5%90%8D%E4%BA%BA%E5%90%8D%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<p>What I hear, I forget; What I see, I remember; What I do, I understand.</p><p>耳听为虚，眼见为实；实践出真知。</p><p>—— 孔子</p><hr><p>The true voyage of discovery consists not of going to new places, but of having a new pair of eyes.</p><p>真正的发现之旅，不在于去一个新的地方，而在于拥有一双新的眼睛。</p><p>—— Marcel Proust</p><hr><p>Some simple things, And we make of them something so complex it defeats us, Almost.</p><p>一些简单的事情，我们往往把他搞得跟很复杂以至于几乎使我们失败。</p><p>—— John Ashbery</p><hr><p>Counting is the religion of this generation, its hope and salvation.</p><p>计算是这一代的信仰，希望，救赎。</p><p>—— Gertrude Stein</p><hr><p>It’s a poor sort of memory that only works backward.</p><p>记忆如此悲怜，只能回溯过去。</p><p>—— lewis Carroll</p><hr><p>Make everything as simple as possible, but not simpler.</p><p>让每件事尽可能简单，而又不简单过度。</p><p>—— 阿尔伯特 · 爱因斯坦</p><hr><p>Form ever follows function.</p><p>形式永远追随功能。</p><p>—— Louis Sullivan</p><hr><p>What’s in a name? That which we call a rose by any other name would smell as sweet.</p><p>名称有什么关系呢，玫瑰不叫玫瑰，依然芳香如故。</p><p>—— 莎士比亚</p><hr><p>Programmes are creators of universes for which they alone are responsible. Universes of virtually unlimited complexity can be created in the form of computer programs.</p><p>程序员对他们所创造的宇宙全权负责，因他们是这些宇宙的创造者。以计算机程序的形式，可以创造出几乎无限复杂的宇宙。</p><p>—— Joseph Weizenbaum</p><hr><p>If everything seems under control, you’re just not going fast enough.</p><p><strong>若一切看上去还都在掌控之中，那就说明你跑得还不够快。</strong></p><p>—— Mario Andretti</p><hr><p>High thoughs need a high language.</p><p>职高的思想需要至高的语言。</p><p>—— Aristophanes</p><hr><p>Neither can embellishments of language be found without arrangement and expression of thoughts, nor can thoughts be made to shine without the light of language.</p><p>既未组织思想，又未表达思想，语言便暗淡无光；没有语言之光照耀，思想便无法闪光。</p><p>—— Cicero</p><hr><p>The syntactic component of a grammar must specify, for each sentence, a deep structure that determines its semantic interpretation.</p><p>语法规范的语法成分必须为每个句子指定具有确定语义解释的深层结构。</p><p>—— Noam Chomesky</p><hr><p>Civilization progresses by extending the number of operations that we can perform without thinking about them.</p><p>对于不用经过特意思考就能执行的操作，其数量的增长推动文明进步。</p><p>—— Alfred North Whitehead</p><hr><p>We shall not cease from exploration, and at the end we will arrive where we started, and know the place for first time.</p><p>永远不应该停止探索的脚步，知道最后，再次抵达起点，我们才刚开始了解脚下的路。</p><p>—— T. S. Eliot</p><hr><p>Intelligence is the faculty of making artifical objects, expecially tools to make tools.</p><p>智能即知道人造物， 特别是制造制造工具的能力。</p><p>—— Henry Bergson</p>]]></content>
    
    
    
    <tags>
      
      <tag>摘抄</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JSDoc 简要介绍</title>
    <link href="/blog/2021/07/04/JSDoc/"/>
    <url>/blog/2021/07/04/JSDoc/</url>
    
    <content type="html"><![CDATA[<h3 id="JSDoc"><a href="#JSDoc" class="headerlink" title="JSDoc"></a><a href="https://en.wikipedia.org/wiki/JSDoc">JSDoc</a></h3><p>JSDoc 是一种用来注释 JavaScript 源代码的标记语言。使用包含 JSDoc 的注释，程序员可以创建描述程序接口的文档。这种注释，可以被各种工具处理，生成类似 HTML 和 富文本格式的文档。JSDoc 规范基于  <a href="https://en.wikipedia.org/wiki/CC_BY-SA_3.0">CC BY-SA 3.0</a> 协议发布，与之对应的文档生成器和解析库是基于 <a href="https://en.wikipedia.org/wiki/Apache_License_2.0">Apache License 2.0</a> 发布的免费软件。</p><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><p>JSDoc 的语法和语义类似于 javadoc 。JSDoc 与之不同之处在于，它专门用于处理 Javascript 的动态行为。</p><p>一个早期的例子，在 Netscape/Mozilla 的 Rhino 项目中，使用类似于 javadoc 语法的 js 文档发布在 1999 年。这是一个用 Java 写的 Javascript 运行系统，它包含一个玩具级的 HTML 生成器，版本更迭到 1.3，它也是 js 功能的一个例子。</p><p>所有主要版本的 JSDoc 都由 Michael Mathews 领导。在 2001 年，他与加拿大程序员 Gabriel Reid 合作，开始 JSDoc.pm 项目，这是一个用 Perl 写的简易系统。系统被托管在 SourceForge 上一个 CVS 仓库中。到 JSDoc 1.0 时，他用 Javascript 重写了系统，在一系列的拓展后，JSDoc 2.0 获得了一个 jsdoc-toolkit 的名字。基于 <a href="https://en.wikipedia.org/wiki/MIT_License">MIT License</a> 发布，被托管在 Google Code 的 Subversion仓库中。到 2011 年，他重构了系统到 JSDoc 3.0 版本，系统被托管在 Github 上。现如今运行在 Node.js 上。</p><h3 id="JSDoc-标签"><a href="#JSDoc-标签" class="headerlink" title="JSDoc 标签"></a>JSDoc 标签</h3><p>在现代的 JSDoc 中，常用的注释标签</p><table><thead><tr><th align="center">标签</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>@author</code></td><td align="center">开发者名字</td></tr><tr><td align="center"><code>@constructor</code></td><td align="center">把函数标记为构造器</td></tr><tr><td align="center"><code>@deprecated</code></td><td align="center">标记函数被弃用</td></tr><tr><td align="center"><code>@exception</code></td><td align="center"><code>@throws</code> 的同义词</td></tr><tr><td align="center"><code>@exports</code></td><td align="center">识别一个被导出成一个模块的成员</td></tr><tr><td align="center"><code>@param</code></td><td align="center">记录一个函数的参数，数据类型可以放在花括号中被添加进来</td></tr><tr><td align="center"><code>@private</code></td><td align="center">表示成员时私有的</td></tr><tr><td align="center"><code>@returns</code></td><td align="center">记录返回值</td></tr><tr><td align="center"><code>@return</code></td><td align="center"><code>@returns</code> 的同义词</td></tr><tr><td align="center"><code>@see</code></td><td align="center">记录到另一个对象的关联</td></tr><tr><td align="center"><code>@todo</code></td><td align="center">记录一些缺少的东西</td></tr><tr><td align="center"><code>@this</code></td><td align="center">明确在一个函数中， this 关键字所指的对象的类型</td></tr><tr><td align="center"><code>@throws</code></td><td align="center">记录方法所抛出的异常</td></tr><tr><td align="center"><code>@version</code></td><td align="center">提供库的版本</td></tr></tbody></table><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/** <span class="hljs-doctag">@class</span> Circle representing a circle. */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Creates an instance of Circle.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: moi</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; r The desired radius of the circle.</span><br><span class="hljs-comment"> */</span><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">r</span>) &#123;<br>    <span class="hljs-comment">/** <span class="hljs-doctag">@private</span> */</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span> = r<br>    <span class="hljs-comment">/** <span class="hljs-doctag">@private</span> */</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">circumference</span> = <span class="hljs-number">2</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * r<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Creates a new Circle from a diameter.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; d The desired diameter of the circle.</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">Circle</span>&#125; The new Circle object.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">fromDiameter</span>(<span class="hljs-params">d</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>(d / <span class="hljs-number">2</span>)<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Calculates the circumference of the Circle.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@deprecated</span> since 1.1.0; use getCircumference instead</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125; The circumference of the circle.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title function_">calculateCircumference</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span><br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Returns the pre-computed circumference of the Circle.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125; The circumference of the circle.</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@since</span> 1.1.0</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title function_">getCircumference</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">circumference</span><br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Find a String representation of the Circle.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@override</span></span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">Human</span>-readable representation of this Circle.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`[A Circle object with radius of <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.radius&#125;</span>.]`</span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Prints a circle.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Circle</span>&#125; <span class="hljs-variable">circle</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">printCircle</span>(<span class="hljs-params">circle</span>) &#123;<br>    <span class="hljs-comment">/** <span class="hljs-doctag">@this</span> &#123;<span class="hljs-type">Circle</span>&#125; */</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">bound</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>) &#125;<br>    bound.<span class="hljs-title function_">apply</span>(circle)<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，@class 和 @constructor 标签事实上可以被省略。ECMA 语法足够清晰的表明它们，JSDoc 利用了这个。@overrride 也是可以被自动地推断出来的。</p><h3 id="使用中的-JSDoc"><a href="#使用中的-JSDoc" class="headerlink" title="使用中的 JSDoc"></a>使用中的 JSDoc</h3><ul><li>谷歌的闭源 Linter 和 编译器，后者抽取出类型信息来优化 Javascript 的输出</li><li>Typescript 可以对有 JSDoc 类型注释的 js 文件执行类型检查。微软已经指定了一种有着可拓展标签的 TSDoc 语言</li><li>一个很受欢迎的编辑器 Sublime Text 通过 DocBlocker 或者 DoxyDoxygen 插件支持 JSDoc</li><li>在 Apress 的书 Ajax 基础 中， JSDoc 语法具有相当的篇幅</li><li><a href="https://en.wikipedia.org/wiki/IntelliJ_IDEA">IntelliJ IDEA</a>, <a href="https://en.wikipedia.org/wiki/NetBeans">NetBeans</a>, <a href="https://en.wikipedia.org/wiki/Visual_Studio_Code">Visual Studio Code</a> 和 <a href="https://en.wikipedia.org/wiki/RubyMine">RubyMine</a> 支持 JSDoc 语法</li><li>基于 Eclipse <a href="https://en.wikipedia.org/wiki/Aptana_Studio">Aptana Studio</a> 支持 ScriptDoc</li><li><a href="http://mozile.mozdev.org/0.8/doc/jsdoc/index.html">Mozile</a>, the Mozilla Inline Editor 使用了 JSDoc.pm</li><li><a href="https://web.archive.org/web/20150420064930/http://dev.helma.org/">Helma</a> 应用框架使用了 JSDoc</li><li>SproutCore 是使用 JSDoc 生成的</li><li><a href="https://en.wikipedia.org/wiki/Visual_Studio">Visual Studio</a>, <a href="https://en.wikipedia.org/wiki/WebStorm">WebStorm</a> 和许多其他的 IDE、编辑器，提供基于 JSDoc 注释的代码补全和辅助</li><li> <a href="https://en.wikipedia.org/wiki/Atom_(text_editor)">Atom</a> 通过 <a href="https://github.com/tgandrews/atom-easy-jsdoc">atom-easy-jsdoc</a> 插件支持 JSDoc</li></ul><h3 id="参见"><a href="#参见" class="headerlink" title="参见"></a>参见</h3><ul><li><a href="https://en.wikipedia.org/wiki/Comparison_of_documentation_generators">文档生成器的对比</a></li><li><a href="https://en.wikipedia.org/wiki/Google_Closure_Tools">谷歌内部工具</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>翻译 Wiki</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web cache 简要介绍</title>
    <link href="/blog/2021/06/27/Web-cache/"/>
    <url>/blog/2021/06/27/Web-cache/</url>
    
    <content type="html"><![CDATA[<h3 id="Web-cache"><a href="#Web-cache" class="headerlink" title="Web cache"></a><a href="https://zh.wikipedia.org/wiki/Web%E7%BC%93%E5%AD%98">Web cache</a></h3><p>网络缓存，或者说 HTTP 缓存，是用来优化互联网的系统。在应用端和服务器端都有实现。图片或者其他文件的缓存，可以使得在浏览网页的时候，时延更小。</p><h4 id="系统的部分介绍"><a href="#系统的部分介绍" class="headerlink" title="系统的部分介绍"></a>系统的部分介绍</h4><h5 id="正向与反向缓存"><a href="#正向与反向缓存" class="headerlink" title="正向与反向缓存"></a>正向与反向缓存</h5><p>正向缓存是一个在 web 服务器之外，但是在客户端浏览器、ISP 或者公司网络之内的缓存。正向缓存只缓存被大量获取的内容。一个在客户端和服务器之间的代理服务器可以通过 HTTP 请求头来选择是否要存储 web 内容。</p><p>反向缓存位在于一个或者多个 web 服务器前面，用来加速来自网络的请求，和缩减请求峰值的压力。通常表现为一个内容分发系统，在整个网络中保存各点的内容副本。</p><h5 id="HTTP-选项"><a href="#HTTP-选项" class="headerlink" title="HTTP 选项"></a>HTTP 选项</h5><p>超文本传输协议定义了用于控制缓存的三种基本机制：freshness, validation, and invalidation。这在来自服务器的 HTTP 响应消息的中被指定。</p><p>Freshness 允许不在原始服务器上重新检查它而使用响应 ，并且可以由服务器和客户端控制。 例如，到期响应给出了文档过期的日期，并且 Cache-Control: max-age 指令告诉缓存响应可用的秒数。</p><p>Validation 可用于检查缓存的响应过期后是否仍然良好的缓存响应。 例如，如果响应具有 Last-Modified 的 header，则缓存可以使用 If-Modified-Since header 来进行条件请求，以查看它是否已更改。 Etag（实体标签）机制也允许强和弱验证。</p><p>Invalidation 通常是通过缓存传递的另一个请求的副作用。 例如，如果与缓存响应关联的URL随后获取发布，放置或删除请求，则缓存响应将无效。 许多 CDN 和网络设备制造商都用动态缓存替换了这个标准的HTTP缓存控制。</p><h5 id="合法性"><a href="#合法性" class="headerlink" title="合法性"></a>合法性</h5><p>1998年，DMCA为美国法典（17U.S.C.§：512）增加了规则，以便为缓存而豁免系统运营商的版权责任</p><h5 id="服务器端软件"><a href="#服务器端软件" class="headerlink" title="服务器端软件"></a>服务器端软件</h5><p>这是服务器端网络缓存软件列表。</p><table><thead><tr><th align="center">名字</th><th align="center">操作系统</th><th align="center">Forward mode</th><th align="center">Reverse mode</th><th align="center">许可证书</th></tr></thead><tbody><tr><td align="center"><a href="https://en.wikipedia.org/wiki/Apache_HTTP_Server_for_S60">Apache HTTP Server</a></td><td align="center">Windows, OS X, Linux, Unix, FreeBSD, Solaris, Novell NetWare, OS/2, TPF, OpenVMS and eComStation</td><td align="center">Yes</td><td align="center"><a href="https://en.wikipedia.org/wiki/Apache_License_2.0">Apache License 2.0</a></td><td align="center"></td></tr><tr><td align="center"><a href="https://en.wikipedia.org/wiki/AiScaler">aiScaler</a> Dynamic Cache Control</td><td align="center">Linux</td><td align="center"><a href="https://en.wikipedia.org/wiki/Proprietary_software">Proprietary</a></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><a href="https://en.wikipedia.org/wiki/ApplianSys#CACHEbox">ApplianSys CACHEbox</a></td><td align="center">Linux</td><td align="center"><a href="https://en.wikipedia.org/wiki/Proprietary_software">Proprietary</a></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><a href="https://en.wikipedia.org/wiki/Blue_Coat_Systems">Blue Coat</a> ProxySG</td><td align="center">SGOS</td><td align="center">Yes</td><td align="center">Yes</td><td align="center"><a href="https://en.wikipedia.org/wiki/Proprietary_software">Proprietary</a></td></tr><tr><td align="center"><a href="https://en.wikipedia.org/wiki/Nginx">Nginx</a></td><td align="center"><a href="https://en.wikipedia.org/wiki/Linux">Linux</a>, <a href="https://en.wikipedia.org/wiki/BSD">BSD variants</a>, <a href="https://en.wikipedia.org/wiki/OS_X">OS X</a>, <a href="https://en.wikipedia.org/wiki/Solaris_(operating_system)">Solaris</a>, <a href="https://en.wikipedia.org/wiki/AIX">AIX</a>, <a href="https://en.wikipedia.org/wiki/HP-UX">HP-UX</a>, other <a href="https://en.wikipedia.org/wiki/*nix">*nix</a> flavors</td><td align="center">Yes</td><td align="center">Yes</td><td align="center">2-clause <a href="https://en.wikipedia.org/wiki/BSD_licenses">BSD</a>-like</td></tr><tr><td align="center"><a href="https://en.wikipedia.org/wiki/Microsoft_Forefront_Threat_Management_Gateway">Microsoft Forefront Threat Management Gateway</a></td><td align="center">Windows</td><td align="center">Yes</td><td align="center">Yes</td><td align="center"><a href="https://en.wikipedia.org/wiki/Proprietary_software">Proprietary</a></td></tr><tr><td align="center"><a href="https://en.wikipedia.org/wiki/Polipo">Polipo</a></td><td align="center"><a href="https://en.wikipedia.org/wiki/Windows">Windows</a>, <a href="https://en.wikipedia.org/wiki/OS_X">OS X</a>, <a href="https://en.wikipedia.org/wiki/Linux">Linux</a>, <a href="https://en.wikipedia.org/wiki/OpenWrt">OpenWrt</a>, <a href="https://en.wikipedia.org/wiki/FreeBSD">FreeBSD</a></td><td align="center">Yes</td><td align="center">Yes</td><td align="center"><a href="https://en.wikipedia.org/wiki/MIT_License">MIT License</a></td></tr><tr><td align="center"><a href="https://en.wikipedia.org/wiki/Squid_(software)">Squid</a></td><td align="center">Linux, <a href="https://en.wikipedia.org/wiki/Unix_filesystem">Unix</a>, <a href="https://en.wikipedia.org/wiki/Windows_10_version_history">Windows</a></td><td align="center">Yes</td><td align="center">Yes</td><td align="center"><a href="https://en.wikipedia.org/wiki/GNU_General_Public_License">GNU General Public License</a></td></tr><tr><td align="center"><a href="https://en.wikipedia.org/wiki/Traffic_Server">Traffic Server</a></td><td align="center">Linux, Unix</td><td align="center">Yes</td><td align="center">Yes</td><td align="center"><a href="https://en.wikipedia.org/wiki/Apache_License_2.0">Apache License 2.0</a></td></tr><tr><td align="center">Untangle</td><td align="center">Linux</td><td align="center">Yes</td><td align="center">Yes</td><td align="center"><a href="https://en.wikipedia.org/wiki/Proprietary_software">Proprietary</a></td></tr><tr><td align="center"><a href="https://en.wikipedia.org/wiki/Varnish_(software)">Varnish</a></td><td align="center">Linux, Unix</td><td align="center">Yes (possible with a VMOD)</td><td align="center">Yes</td><td align="center"><a href="https://en.wikipedia.org/wiki/BSD_licenses">BSD</a></td></tr><tr><td align="center"><a href="https://en.wikipedia.org/wiki/WinGate">WinGate</a></td><td align="center">Windows</td><td align="center">Yes</td><td align="center">Yes</td><td align="center"><a href="https://en.wikipedia.org/wiki/Proprietary_software">Proprietary</a> / Free for 8 users</td></tr><tr><td align="center">Nuster</td><td align="center">Linux, Unix</td><td align="center">Yes</td><td align="center">Yes</td><td align="center"><a href="https://en.wikipedia.org/wiki/GNU_General_Public_License">GNU General Public License</a></td></tr><tr><td align="center"><a href="https://en.wikipedia.org/wiki/McAfee">McAfee</a> Web Gateway</td><td align="center">McAfee Linux Operating System</td><td align="center">Yes</td><td align="center">Yes</td><td align="center"><a href="https://en.wikipedia.org/wiki/Proprietary_software">Proprietary</a></td></tr></tbody></table><h5 id="进一步了解："><a href="#进一步了解：" class="headerlink" title="进一步了解："></a>进一步了解：</h5><ul><li><a href="https://en.wikipedia.org/wiki/Cache_manifest_in_HTML5">Cache manifest in HTML5</a></li><li><a href="https://en.wikipedia.org/wiki/Content_delivery_network">Content delivery network</a></li><li><a href="https://en.wikipedia.org/wiki/Harvest_project">Harvest project</a></li><li><a href="https://en.wikipedia.org/wiki/Proxy_server">Proxy server</a></li><li><a href="https://en.wikipedia.org/wiki/Web_accelerator">Web accelerator</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>翻译 Wiki</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Github Pages搭建博客</title>
    <link href="/blog/2021/06/21/use-github-pages-build-blog/"/>
    <url>/blog/2021/06/21/use-github-pages-build-blog/</url>
    
    <content type="html"><![CDATA[<h2 id="Github-Pages-建站教程"><a href="#Github-Pages-建站教程" class="headerlink" title="Github Pages 建站教程"></a>Github Pages 建站教程</h2><p>电脑中已安装：</p><ul><li><a href="http://nodejs.org/">Node.js</a> (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)</li><li><a href="http://git-scm.com/">Git</a></li></ul><p>在所需的应用程序安装完成后，即可使用 npm 安装 hexo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g hexo-cli<br></code></pre></td></tr></table></figure><p>安装完 hexo 后，执行下列命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init &lt;folder&gt;<br><span class="hljs-built_in">cd</span> &lt;folder&gt;<br>npm install<br></code></pre></td></tr></table></figure><p>会生成下列所示的文件目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>├── _config.yml <span class="hljs-comment"># 修改网站的配置信息</span><br>├── package.json<br>├── scaffolds <span class="hljs-comment"># 存储模板文件，当您新建文章时，Hexo 会根据 scaffold 来建立文件</span><br>├── <span class="hljs-built_in">source</span><br>|   ├── _drafts<br>|   └── _posts<br>└── themes<br></code></pre></td></tr></table></figure><h2 id="该写点啥了"><a href="#该写点啥了" class="headerlink" title="该写点啥了"></a>该写点啥了</h2><p>运行命令，生成要转为 html 文件的 md 文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new [layout] &lt;title&gt;<br></code></pre></td></tr></table></figure><p>eg. <code>hexo new &quot;post title with whitespace&quot;</code> 会生成默认布局的以 <code>post title with whitespace</code> 为标题的 md 文件。</p><p>运行命令，生成静态文件，即要渲染到 Github Pages 的网页文件.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo generate <br></code></pre></td></tr></table></figure><p>运行命令，启动服务器，查看效果。默认情况下，访问网址为： <code>http://localhost:4000/</code>。每次修改后，都要重新运行命令，查看更新效果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo server<br></code></pre></td></tr></table></figure><h2 id="最后一步，部署到-Github-Pages"><a href="#最后一步，部署到-Github-Pages" class="headerlink" title="最后一步，部署到 Github Pages"></a>最后一步，部署到 Github Pages</h2><p>首先安装 <a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><p>再修改 _config.yml 的配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">deploy:<br>  <span class="hljs-built_in">type</span>: git<br>  <span class="hljs-comment"># repo: &lt;repository url&gt; #https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io</span><br>  repo: git@github.com:Hercules11/Hercules11.github.io.git <span class="hljs-comment"># 走 ssh 通道, 不用输入用户名、密码</span><br>  branch: [branch] <span class="hljs-comment"># 页面文件所在分支</span><br></code></pre></td></tr></table></figure><h2 id="Hexo-部署的原理"><a href="#Hexo-部署的原理" class="headerlink" title="Hexo 部署的原理"></a>Hexo 部署的原理</h2><p>当执行 <code>hexo deploy</code> 时，Hexo 会将 <code>public</code> 目录中的文件和目录推送至 <code>_config.yml</code> 中指定的远端仓库和分支中，并且<strong>完全覆盖</strong>该分支下的已有内容。</p><h2 id="自动化部署"><a href="#自动化部署" class="headerlink" title="自动化部署"></a>自动化部署</h2><p>参考： <a href="https://chuyang-fe.github.io/2021/03/28/%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/">个人博客搭建指南</a> </p>]]></content>
    
    
    
    <tags>
      
      <tag>实战教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
